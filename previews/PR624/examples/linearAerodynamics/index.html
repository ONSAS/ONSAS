<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear aerodynamics · ONSAS.m</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ONSAS.m logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ONSAS.m</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Learning by examples</span><ul><li><a class="tocitem" href="../staticVonMisesTruss/">Static Von-Mises Truss</a></li><li><a class="tocitem" href="../springMass/">Spring-mass system</a></li><li><a class="tocitem" href="../uniaxialExtension/">Uniaxial extension</a></li><li><a class="tocitem" href="../uniaxialCompression/">Uniaxial compression</a></li><li><a class="tocitem" href="../cantileverBeam/">Cantilever Beam</a></li><li><a class="tocitem" href="../beamLinearVibration/">Linear beam vibration</a></li><li><a class="tocitem" href="../linearCylinderPlaneStrain/">Linear elastic cylinder</a></li><li class="is-active"><a class="tocitem" href>Linear aerodynamics</a><ul class="internal"><li><a class="tocitem" href="#Analytic-solution"><span>Analytic solution</span></a></li><li><a class="tocitem" href="#Numerical-solution"><span>Numerical solution</span></a></li><li><a class="tocitem" href="#Verification"><span>Verification</span></a></li></ul></li><li><a class="tocitem" href="../simplePropeller/">Propeller model</a></li><li><a class="tocitem" href="../nonLinearAerodynamics/">Non-linear aerodynamics</a></li></ul></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../howtouse/install/">Installation</a></li><li><a class="tocitem" href="../../howtouse/creatingModels/">Creating Models</a></li><li><a class="tocitem" href="../../theory/references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning by examples</a></li><li class="is-active"><a href>Linear aerodynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear aerodynamics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ONSAS/ONSAS.m/blob/master/docs/src/examples/linearAerodynamics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Aerodynamic-linear-static-cantilever-beam-example"><a class="docs-heading-anchor" href="#Aerodynamic-linear-static-cantilever-beam-example">Aerodynamic linear static cantilever beam example</a><a id="Aerodynamic-linear-static-cantilever-beam-example-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-linear-static-cantilever-beam-example" title="Permalink"></a></h1><p><a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/linearAerodynamics/linearAerodynamics.m"><img src="https://img.shields.io/badge/script-url-blue" alt="Octave script"/></a></p><p>In this tutorial, the linear steady analysis of a cantilever beam is presented and how to solve it using ONSAS is described. The aim of this example is to validate the aerodynamic steady and uniform wind loads applied to a cantilever beam undergoing small displacements and strains. The aerodynamic force variation due to the beam deformation is not considered. Under these hypotheses an analytic solution is available. </p><p>The beam is submitted to a uniform air wind velocity field <span>$v_a$</span> at 20 degrees and atmospheric pressure along axis <span>$z$</span>, and because of an ice accretion on the frame cross section, lift and drag forces are induced. The lift, drag and moment fluid forces are characterized with their respective aerodynamic coefficients <span>$c_d$</span> <span>$c_l$</span> and <span>$c_m$</span> are based on <a href="http://pure-oai.bham.ac.uk/ws/portalfiles/portal/44736207/He_Macdonald_2017_Aeroelastic_stability_of_a_3DOF_system_based_on_quasi_steady_theory_with_reference_to_inertial_coupling.pdf">this reference</a>.  The beam has a length <span>$L$</span> and a hollow cylindrical cross-section with diameter <span>$d_{ext}$</span> and a thickness <span>$b$</span> as it is shown in the following figure. </p><img src="../../assets/linearAerodynamics/ilusLinearAerodynamics.svg" alt="general sketch" width="700"/><h2 id="Analytic-solution"><a class="docs-heading-anchor" href="#Analytic-solution">Analytic solution</a><a id="Analytic-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Analytic-solution" title="Permalink"></a></h2><hr/><p>The analytic steady solution is obtained using the Euler-Bernoulli beam theory. The rotations are: </p><p class="math-container">\[ \theta_z(x)= \frac{qy}{6 EI_{zz}} \left( (x-L)^3 +L^3 \right)\]</p><p class="math-container">\[ \theta_y(x)= \frac{qz}{6 EI_{yy}} \left( (x-L)^3 +L^3 \right)\]</p><p class="math-container">\[ \theta_x(x)= \frac{qm}{2 JG} \left( (L-x)^2 -L^2 \right)\]</p><p>in which <span>$q = 1/2 \rho v_a^2 d_{ext}$</span>, <span>$q_z = q c_d$</span>, <span>$q_y = q c_l$</span> and <span>$q_m = q c_m$</span>.</p><p>Integrating the rotations we obtain the displacements: </p><p class="math-container">\[ u_y(x)= -\frac{qy}{24 EI_{zz}} \left( 6L^2x^2 - 4Lx^3 + x^4 \right)\]</p><p class="math-container">\[ u_z(x)= -\frac{qz}{24 EI_{yy}} \left( 6L^2x^2 - 4Lx^3 + x^4 \right) \]</p><h2 id="Numerical-solution"><a class="docs-heading-anchor" href="#Numerical-solution">Numerical solution</a><a id="Numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution" title="Permalink"></a></h2><hr/><p>Before defining the structs, the workspace is cleaned and the ONSAS directory is added:</p><pre><code class="nohighlight hljs">close all, clear all ; addpath( genpath( [ pwd &#39;/../../src&#39;] ) );</code></pre><p>The material parameters, Young <span>$E$</span> and shear <span>$G$</span> moduli and the Poisson&#39;s ratio <span>$\nu$</span> are:</p><pre><code class="nohighlight hljs">E = 70e9 ;  nu = 0.3 ; G = E / (2 * (1+nu)) ;</code></pre><p>Geometrical dimensions sketched in Fig 1 are:</p><pre><code class="nohighlight hljs">l = 20 ; dext = .5 ;  b = 1e-3  ; dint  = dext - 2*b    ;
A = pi * (dext^2 - dint^2) / 4  ;
J = pi * (dext^4 - dint^4) / 32 ; Iyy = J/2 ; Izz = Iyy ;</code></pre><p>The fluid properties are:</p><pre><code class="nohighlight hljs">rhoA = 1.225 ; nuA = 1.6e-5;</code></pre><p>the number of elements employed to discretize the beam is declared as a global variable:</p><pre><code class="nohighlight hljs">global numElements
numElements = 10 ;</code></pre><h3 id="MEBI-parameters"><a class="docs-heading-anchor" href="#MEBI-parameters">MEBI parameters</a><a id="MEBI-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters" title="Permalink"></a></h3><h3 id="materials"><a class="docs-heading-anchor" href="#materials">materials</a><a id="materials-1"></a><a class="docs-heading-anchor-permalink" href="#materials" title="Permalink"></a></h3><p>Since the example contains only one linear Euler Bernoulli element the fields of the <code>materials</code> struct will have only one entry. Although, the constitutive behavior law selected is Saint-Venant-Kirchhoff:</p><pre><code class="nohighlight hljs">materials.hyperElasModel  = &#39;linearElastic&#39; ;
materials.hyperElasParams = [ E nu ]        ;</code></pre><h3 id="elements"><a class="docs-heading-anchor" href="#elements">elements</a><a id="elements-1"></a><a class="docs-heading-anchor-permalink" href="#elements" title="Permalink"></a></h3><p>Two different types of elements are considered, node and frames. The nodes will be assigned in the first entry (index <span>$1$</span>) and the beam at the index <span>$2$</span>. The <em>elemType</em> field is then:</p><pre><code class="nohighlight hljs">elements(1).elemType = &#39;node&#39;  ;
elements(2).elemType = &#39;frame&#39; ;</code></pre><p>The node type has no cross-section geometry to assign (an empty array is automatically set). Since the frame element has no implemented a hollow cylindrical cross-section, then a <code>&#39;generic&#39;</code> cross-section (in <span>$y$</span> and <span>$z$</span>) is used. Thus the <em>elemCrossSecParams</em> field is:</p><pre><code class="nohighlight hljs">elements(2).elemCrossSecParams{1,1} = &#39;generic&#39; ;
elements(2).elemCrossSecParams{2,1} = [ A J Iyy Izz ] ;</code></pre><p>Now the parameters to include aerodynamic forces automatically on the frame element are defined. The drag lift, and moment cross section functions are set in concordance with the function names located at the same example folder. Thus the <em>aeroCoefs</em> field is a row cell defined as:</p><pre><code class="nohighlight hljs">elements(2).aeroCoefs   = {&#39;dragCoefFunctionLA&#39;; &#39;liftCoefFunctionLA&#39;; &#39;momentCoefFunctionLA&#39;} ;</code></pre><p>Next the <em>elemTypeAero</em> field contain the information of the chord vector. This vector is defined first considering the orientation of the cross section set up in lift, drag and moment experiments, and then how that cross section is located for the example. In this case the orientation of the chord vector is along <span>$y$</span>. In general note that the chord vector <span>$t_{ch}$</span> must be given in reference (non canonical configurations). In this example the cable is oriented along <span>$y$</span> so the direction will be <span>$[0~1~0]$</span> as it is shown in Fig 1. Also the length of the chord is added to the norm of the chord vector, for cylindrical cantilever beams is <span>$d_{ext}$</span>. The aerodynamic tangent matrix is the last boolean element of the vector <code>elemTypeAero</code>, and in this case is set as false.  All this information is added into <em>elemTypeAero</em> field of <code>elements</code> struct such that:</p><pre><code class="nohighlight hljs">numGaussPoints  = 4 ; 
computeAeroTangMatrix = false ;
elements(2).elemTypeAero   = [0 dext 0 numGaussPoints computeAeroTangMatrix];</code></pre><p>in which 4 Gauss integration points are employed to compute the aerodynamic force. This value is enough in most cases. </p><h3 id="boundaryConds"><a class="docs-heading-anchor" href="#boundaryConds">boundaryConds</a><a id="boundaryConds-1"></a><a class="docs-heading-anchor-permalink" href="#boundaryConds" title="Permalink"></a></h3><p>Only one welded (6 degrees of freedom are set to zero) boundary condition (BC) is considered:</p><pre><code class="nohighlight hljs">boundaryConds(1).imposDispDofs = [ 1 2 3 4 5 6 ] ;
boundaryConds(1).imposDispVals = [ 0 0 0 0 0 0 ] ;</code></pre><h3 id="mesh-parameters"><a class="docs-heading-anchor" href="#mesh-parameters">mesh parameters</a><a id="mesh-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#mesh-parameters" title="Permalink"></a></h3><p>The coordinates of the mesh nodes are given by the matrix:</p><pre><code class="nohighlight hljs">mesh.nodesCoords = [ (0:(numElements))&#39;*l/numElements  zeros(numElements+1,2) ] ;</code></pre><p>The connectivity is introduced using the <em>conecCell</em>. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of nodes that compose the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:</p><pre><code class="nohighlight hljs">mesh.conecCell = { } ;</code></pre><p>then the first welded node is defined with material (M) zero since nodes don&#39;t have material, the first element (E) type (the first entry of the <code>elements</code> struct), and (B) is the first entry of the the <code>boundaryConds</code> struct. Finally the node is assigned:</p><pre><code class="nohighlight hljs">mesh.conecCell{ 1, 1 } = [ 0 1 1   1 ] ;</code></pre><p>Next the frame elements MEB parameters are set. The frame material is the first material of <code>materials</code> struct, then <span>$1$</span> is assigned. The second entry of the <code>elements</code> struct correspond to the frame element employed, so <span>$2$</span> is set. Finally no BC is required for this element, then <span>$0$</span> is used.  Consecutive nodes build the element so then the <code>mesh.conecCell</code> is:</p><pre><code class="nohighlight hljs">for i=1:numElements,
  mesh.conecCell{ i+1,1 } = [ 1 2 0   i i+1 ] ;
end</code></pre><h3 id="initial-Conditions"><a class="docs-heading-anchor" href="#initial-Conditions">initial Conditions</a><a id="initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#initial-Conditions" title="Permalink"></a></h3><p>Any non-homogeneous initial condition (IC) are set for this case, then an empty struct is used:</p><pre><code class="nohighlight hljs">initialConds = struct() ;</code></pre><h3 id="analysisSettings"><a class="docs-heading-anchor" href="#analysisSettings">analysisSettings</a><a id="analysisSettings-1"></a><a class="docs-heading-anchor-permalink" href="#analysisSettings" title="Permalink"></a></h3><p>The fluid properties are set into <em>fluidProps</em> field into <code>analysisSettings</code> struct. In this field the fluid velocity, viscosity and density are defined, This will apply a external fluid loads according to the quasi-steady theory for each element with <em>elemTypeAero</em> field into the <code>elements</code> struct. The name of the wind velocity function located on the same example path is introduced as a string &#39;windVel&#39;: </p><pre><code class="nohighlight hljs">analysisSettings.fluidProps = {rhoA; nuA; &#39;windVelLA&#39;} ;</code></pre><p>The geometrical non-linear effects are not considered in this case to compute the aerodynamic force. As consequence the wind load forces are computed on the reference configuration, and remains constant during the beam deformation. The field  <em>geometricNonLinearAero</em> into  <code>analysisSettings</code> struct is then set to:</p><pre><code class="nohighlight hljs">analysisSettings.geometricNonLinearAero = false;</code></pre><p>since this problem is static, then a N-R method is employed. The convergence of the method is accomplish with ten equal load steps. The time variable for static cases is a load factor parameter that must be configured into the <code>windVel.m</code> function. A linear profile is considered for ten equal velocity load steps as:</p><pre><code class="nohighlight hljs">analysisSettings.deltaT        =   .1            ;
analysisSettings.finalTime     =   1             ;
analysisSettings.methodName    = &#39;newtonRaphson&#39; ;</code></pre><p>Next the maximum number of iterations per load(time) step, the residual force and the displacements tolerances are set to: </p><pre><code class="nohighlight hljs">analysisSettings.stopTolDeltau =   1e-6          ;
analysisSettings.stopTolForces =   1e-6          ;
analysisSettings.stopTolIts    =   10            ;</code></pre><h3 id="otherParams"><a class="docs-heading-anchor" href="#otherParams">otherParams</a><a id="otherParams-1"></a><a class="docs-heading-anchor-permalink" href="#otherParams" title="Permalink"></a></h3><p>The name of the problem and vtk format output are selected: </p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;linearAerodynamics&#39;;
otherParams.plotsFormat = &#39;vtk&#39; ;</code></pre><h3 id="Case-1:-hydrodynamic-ONSAS-element"><a class="docs-heading-anchor" href="#Case-1:-hydrodynamic-ONSAS-element">Case 1: hydrodynamic ONSAS element</a><a id="Case-1:-hydrodynamic-ONSAS-element-1"></a><a class="docs-heading-anchor-permalink" href="#Case-1:-hydrodynamic-ONSAS-element" title="Permalink"></a></h3><p>The first case is executed used the internal ONSAS functions such as <code>hydroFrameForce.m</code>to compute the aerodynamic forces:</p><p>The ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved in <code>matUsCase1</code>matrix:</p><pre><code class="nohighlight hljs">[matUsCase1, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><h3 id="Case-2:-user-load-function"><a class="docs-heading-anchor" href="#Case-2:-user-load-function">Case 2: user load function</a><a id="Case-2:-user-load-function-1"></a><a class="docs-heading-anchor-permalink" href="#Case-2:-user-load-function" title="Permalink"></a></h3><p>In this case the wind load is added through a user load function. Since geometric-nonlinearties are not considered in this example then wind loads can be computed externally. First the previous aerodynamic parameters of the element are deleted:</p><pre><code class="nohighlight hljs">analysisSettingsCase2 = analysisSettings ; elementsCase2 = elements ;
analysisSettingsCase2.fluidProps = [] ; elementsCase2(2).elemTypeAero = [] ; elementsCase2(2).aeroCoefs = [] ;</code></pre><p>now the boundary condition with the name of the user load function is declared into the <code>boundaryConds</code> struct</p><pre><code class="nohighlight hljs">boundaryConds(2).userLoadsFilename = &#39;myLinearAeroLA&#39; ;</code></pre><p>and finally is assigned to all cantilever beam nodes:</p><pre><code class="nohighlight hljs">for i=1:numElements + 1,
  mesh.conecCell{ i+numElements+1,1 } = [ 0 1 2 0  i ] ;
end</code></pre><p>The ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved in <code>matUsCase2</code>matrix:</p><pre><code class="nohighlight hljs">[matUsCase2, ~] = ONSAS( materials, elementsCase2, boundaryConds, initialConds, mesh, analysisSettingsCase2, otherParams ) ;</code></pre><h2 id="Verification"><a class="docs-heading-anchor" href="#Verification">Verification</a><a id="Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Verification" title="Permalink"></a></h2><hr/><p>This example validation is ascertained comparing analytical and numerical solutions.</p><h3 id="Symbolic-solution"><a class="docs-heading-anchor" href="#Symbolic-solution">Symbolic solution</a><a id="Symbolic-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-solution" title="Permalink"></a></h3><p>For such propose the angle of incidence and the wind properties are computed as:</p><pre><code class="nohighlight hljs">% then characteristic dimension is extracted executing: 
dimCaracteristic = norm(elements(2).elemTypeAero (1:3) ) ;
% the angle of attack is: 
betaRel = acos(dot(elements(2).elemTypeAero( 1:3 ) , [0 0 1] ));
% the wind velocity is:
windVel = feval(analysisSettings.fluidProps{3,:}, betaRel, analysisSettings.finalTime) ;
% Extract the aerodynamic coefficients 
userDragCoef   = elements(2).aeroCoefs{1,:} ; 
userLiftCoef   = elements(2).aeroCoefs{2,:} ; 
userMomentCoef = elements(2).aeroCoefs{3,:} ; 
% Delete spaces
userDragCoef   = strrep(userDragCoef,&#39; &#39;,&#39;&#39;)   ;
userLiftCoef   = strrep(userLiftCoef,&#39; &#39;,&#39;&#39;)   ;
userMomentCoef = strrep(userMomentCoef,&#39; &#39;,&#39;&#39;) ;

% the drag, lift and eventually moment coefficients are:
if ~isempty(userDragCoef)
  c_d = feval(userDragCoef, betaRel);
else
  c_d = 0;
end
if ~isempty(userLiftCoef)
  c_l = feval(userLiftCoef, betaRel);
else
  c_l = 0;
end
if ~isempty(userMomentCoef)
  c_m = feval(userMomentCoef, -betaRel);
else
  c_m = 0;
end</code></pre><p>Then the dynamic pressures <span>$q_0$</span> defined above are expressed such that: </p><pre><code class="nohighlight hljs">q = 1/2 * rhoA * (windVel(3)^2 + windVel(2)^2) ;</code></pre><p>next the loads per unit of length are  </p><pre><code class="nohighlight hljs">qz = q * c_d * dimCaracteristic ; qy = q * c_l * dimCaracteristic ;  qm = q * c_m * dimCaracteristic ; </code></pre><p>then an analytic x vector to evaluate the deformed analytic solution is build as </p><pre><code class="nohighlight hljs">sizeAnalyticX = 100 ;
xAnalytic = linspace(0,l,sizeAnalyticX)&#39; ;</code></pre><p>The linear displacements symbolic solutions are:</p><pre><code class="nohighlight hljs">ydefAnalytic = @(x) -qy / (24*E*Izz) * (6*l^2*x.^2 -4*l*x.^3+x.^4) ;
zdefAnalytic = @(x) qz  / (24*E*Izz) * (6*l^2*x.^2 -4*l*x.^3+x.^4) ;</code></pre><p>then the angular displacements symbolic solutions are:</p><pre><code class="nohighlight hljs">thetaXAnalytic = @(x)  -qm  / (2*J*G) * ( (l - x).^2 - l ^2 )         ;
thetaYAnalytic = @(x) -qz  / (6*E*Iyy) * (3* l^2 * x -3*l*x.^2+x.^3) ;
thetaZAnalytic = @(x) -qy  / (6*E*Izz) * (3* l^2 * x -3*l*x.^2+x.^3) ;</code></pre><h3 id="Numeric-solution"><a class="docs-heading-anchor" href="#Numeric-solution">Numeric solution</a><a id="Numeric-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-solution" title="Permalink"></a></h3><p>The numerical solution is extracted:</p><pre><code class="nohighlight hljs">xref    = mesh.nodesCoords(:,1)     ;
yref    = mesh.nodesCoords(:,2)     ;
zref    = mesh.nodesCoords(:,3)     ;
% Numerical solution case 1
ydefNumCase1 = yref + matUsCase1(3:6:end,end) ;
zdefNumCase1 = zref + matUsCase1(5:6:end,end) ;
thetaXdefNumCase1 = matUsCase1(2:6:end,end)   ;
thetaYdefNumCase1 = matUsCase1(4:6:end,end)   ;
thetaZdefNumCase1 = matUsCase1(6:6:end,end)   ;
% Numerical solution case 1
ydefNumCase2 = yref + matUsCase2(3:6:end,end) ;
zdefNumCase2 = zref + matUsCase2(5:6:end,end) ;
thetaXdefNumCase2 = matUsCase2(2:6:end,end)   ;
thetaYdefNumCase2 = matUsCase2(4:6:end,end)   ;
thetaZdefNumCase2 = matUsCase2(6:6:end,end)   ;</code></pre><h3 id="Verification-boolean"><a class="docs-heading-anchor" href="#Verification-boolean">Verification boolean</a><a id="Verification-boolean-1"></a><a class="docs-heading-anchor-permalink" href="#Verification-boolean" title="Permalink"></a></h3><p>The verification boolean is computed as <span>$||U_n - U_a || / || U_a || &lt; 10^{-3}$</span></p><pre><code class="nohighlight hljs">vecDifCase1 =  [ norm( thetaXdefNumCase1 - thetaXAnalytic (xref) ) ;...
                 norm( ydefNumCase1      - ydefAnalytic   (xref) ) ;...
                 norm( thetaYdefNumCase1 - thetaYAnalytic (xref) ) ;...
                 norm( zdefNumCase1      - zdefAnalytic   (xref) ) ;...
                 norm( thetaZdefNumCase1 - thetaZAnalytic (xref) ) ] ;

vecDifCase2 =  [ norm( thetaXdefNumCase2 - thetaXAnalytic (xref) ) ;...
                 norm( ydefNumCase2      - ydefAnalytic   (xref) ) ;...
                 norm( thetaYdefNumCase2 - thetaYAnalytic (xref) ) ;...
                 norm( zdefNumCase2      - zdefAnalytic   (xref) ) ;...
                 norm( thetaZdefNumCase2 - thetaZAnalytic (xref) ) ] ;

vecRef =  [ norm( thetaXAnalytic(xref) ) ;...
            norm( ydefAnalytic  (xref) ) ;...
            norm( thetaYAnalytic(xref) ) ;...
            norm( zdefAnalytic  (xref) ) ;...
            norm( thetaZAnalytic(xref) ) ] ;

verifBooleanVecCase1 = vecDifCase1 &lt;=  1e-3 * vecRef ;
verifBooleanVecCase2 = vecDifCase2 &lt;=  1e-3 * vecRef ;
verifBooleanCase1    =  all(verifBooleanVecCase1)    ;
verifBooleanCase2    =  all(verifBooleanVecCase2)    ;
verifBoolean         = verifBooleanCase1 &amp;&amp; verifBooleanCase2 ;</code></pre><h3 id="Plot-verification"><a class="docs-heading-anchor" href="#Plot-verification">Plot verification</a><a id="Plot-verification-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-verification" title="Permalink"></a></h3><p>The plot parameters are:</p><pre><code class="nohighlight hljs">lw = 2 ; ms = 5 ;
labelTitle= [&#39; Validating solution with &#39; num2str(numElements) &#39; elements&#39; ];
axislw = 1 ; axisFontSize = 20 ; legendFontSize = 15 ; curveFontSize = 15 ;       </code></pre><p>The linear displacements verification is plotted using:  </p><pre><code class="nohighlight hljs">figure(1)
hold on, grid on
plot(xref      , zdefNumCase1            ,&#39;ro&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms    ) ;
plot(xref      , zdefNumCase2            ,&#39;rs&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms+5 ) ;
plot(xAnalytic , zdefAnalytic(xAnalytic) ,&#39;r-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms    ) ;
plot(xref      , ydefNumCase1            ,&#39;bo&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;  , ms    ) ;
plot(xref      , ydefNumCase2            ,&#39;bs&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms+5 ) ;
plot(xAnalytic , ydefAnalytic(xAnalytic) ,&#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms    ) ;
legend(&#39;z_nC1&#39;,&#39;z_nC2&#39;, &#39;z_a&#39;,  &#39;y_nC1&#39;, &#39;y_nC2&#39;, &#39;y_a&#39;, &#39;location&#39;, &#39;northwest&#39;)
labx=xlabel(&#39; x (m)&#39;);    laby=ylabel(&#39;Displacements (m)&#39;);
title (labelTitle)
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
% print(&#39;output/linearDispAero.png&#39;,&#39;-dpng&#39;)
% print(&#39;../../docs/src/assets/linearAerodynamics/linearDispAero.png&#39;,&#39;-dpng&#39;)
close(1)    </code></pre><img src="../../assets/linearAerodynamics/linearDispAero.png" alt="plot check linear displacements" width="500"/><p>The angular displacements verification is plotted using:  </p><pre><code class="nohighlight hljs">figure(2)
hold on, grid on
plot(xref      , rad2deg(thetaXdefNumCase1)              , &#39;go&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaXdefNumCase2)              , &#39;gs&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms + 10) ;
plot(xAnalytic , rad2deg(thetaXAnalytic(xAnalytic))      , &#39;g-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaYdefNumCase1)              , &#39;ro&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaYdefNumCase2)              , &#39;rs&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms + 10) ;
plot(xAnalytic , rad2deg(thetaYAnalytic(xAnalytic))      , &#39;r-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaZdefNumCase1)              , &#39;bo&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaZdefNumCase2)              , &#39;bs&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms + 10) ;
plot(xAnalytic , rad2deg(thetaZAnalytic(xAnalytic))      , &#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
legend(&#39;\theta x_nC1&#39;,&#39;\theta x_nC2&#39;, &#39;\theta x_a&#39;, &#39;\theta y_nC1&#39;,&#39;\theta y_nC2&#39;, &#39;\theta y_a&#39;, &#39;\theta z_nC1&#39;,&#39;\theta z_nC2&#39;, &#39;\theta z_a&#39;,  &#39;location&#39;, &#39;eastoutside&#39; )
labx=xlabel(&#39; x (m)&#39;); laby=ylabel(&#39;Angle (º)&#39;);
title (labelTitle)
set(legend, &#39;linewidth&#39; , axislw, &#39;fontsize&#39;, legendFontSize) ;
set(gca   , &#39;linewidth&#39; , axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx  , &#39;FontSize&#39;  , axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
print(&#39;output/angDispAero.png&#39;,&#39;-dpng&#39;)  
% print(&#39;../../docs/src/assets/linearAerodynamics/angDispAero.png&#39;,&#39;-dpng&#39;)  
close(2)
</code></pre><img src="../../assets/linearAerodynamics/angDispAero.png" alt="plot check angular displacements" width="500"/><p>The 3D deformed configuration is plotted executing:  </p><pre><code class="nohighlight hljs">figure(3)
hold on, grid on
plot3(xref     , yref                       , zref                   ,&#39;k-&#39; , &#39;linewidth&#39;, lw + 300, &#39;markersize&#39;, ms+200 );
plot3(xAnalytic, ydefAnalytic(xAnalytic) , zdefAnalytic(xAnalytic),&#39;r-&#39; , &#39;linewidth&#39;, lw      , &#39;markersize&#39;, ms     );
plot3(xref     , ydefNumCase1            , zdefNumCase1           ,&#39;bo&#39; , &#39;linewidth&#39;, lw      , &#39;markersize&#39;, ms     );
plot3(xref     , ydefNumCase2            , zdefNumCase2           ,&#39;gs&#39; , &#39;linewidth&#39;, lw      , &#39;markersize&#39;, ms +5    );
legend(&#39;Reference config&#39;   , &#39;Analytic def config&#39; , &#39;Numerical def config c1&#39;, &#39;Numerical def config c2&#39;, &#39;location&#39;,&#39;northEast&#39;)
labx=xlabel( &#39;x (m)&#39; )      ; laby=ylabel(&#39;y(m)&#39;)   ; labz=zlabel(&#39;z(m)&#39;)  ;
set(legend, &#39;linewidth&#39;, axislw       , &#39;fontsize&#39;  , legendFontSize )     ;
set(gca   , &#39;linewidth&#39;, axislw       , &#39;fontsize&#39;  , curveFontSize  )     ;
set(labx  , &#39;FontSize&#39; , axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize); set(labz, &#39;FontSize&#39;, axisFontSize) ;
view([0.5 +0.5 -1])
% print(&#39;output/defaAero.png&#39;,&#39;-dpng&#39;)
% print(&#39;../../docs/src/assets/linearAerodynamics/defAero.png&#39;,&#39;-dpng&#39;)
close(3)    </code></pre><img src="../../assets/linearAerodynamics/defAero.png" alt="plot check deformed configurations" width="500"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linearCylinderPlaneStrain/">« Linear elastic cylinder</a><a class="docs-footer-nextpage" href="../simplePropeller/">Propeller model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 22 February 2023 09:04">Wednesday 22 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
