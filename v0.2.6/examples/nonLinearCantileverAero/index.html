<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Non-linear aerodynamic cantilever beam · ONSAS.m</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ONSAS.m logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ONSAS.m</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Learning by examples</span><ul><li><a class="tocitem" href="../staticVonMisesTruss/">Static Von-Mises Truss</a></li><li><a class="tocitem" href="../springMass/">Spring-mass system</a></li><li><a class="tocitem" href="../uniaxialExtension/">Uniaxial extension</a></li><li><a class="tocitem" href="../cantileverBeam/">Cantilever Beam</a></li><li><a class="tocitem" href="../semiSphereWithInclusion/">Solid with inclusion</a></li><li><a class="tocitem" href="../staticAeroLinearCantilever/">Linear static aerodynamic cantilever beam</a></li><li class="is-active"><a class="tocitem" href>Non-linear aerodynamic cantilever beam</a><ul class="internal"><li><a class="tocitem" href="#Small-displacements-2D-case"><span>Small displacements 2D case</span></a></li><li><a class="tocitem" href="#Large-displacements-2D-case"><span>Large displacements 2D case</span></a></li><li><a class="tocitem" href="#Large-displacements-3D-case"><span>Large displacements 3D case</span></a></li></ul></li></ul></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../howtouse/install/">Installation</a></li><li><a class="tocitem" href="../../howtouse/creatingModels/">Creating Models</a></li><li><a class="tocitem" href="../../theory/references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning by examples</a></li><li class="is-active"><a href>Non-linear aerodynamic cantilever beam</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Non-linear aerodynamic cantilever beam</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ONSAS/ONSAS.m/blob/master/docs/src/examples/nonLinearCantileverAero.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Aerodynamic-non-linear-cantilever-beam-example"><a class="docs-heading-anchor" href="#Aerodynamic-non-linear-cantilever-beam-example">Aerodynamic non-linear cantilever beam example</a><a id="Aerodynamic-non-linear-cantilever-beam-example-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-non-linear-cantilever-beam-example" title="Permalink"></a></h1><hr/><p>In this tutorial, the aerodynamic non-linear cantilever beam example is solved using ONSAS. The aim of this problem is to validate aerodynamic steady wind loads applied to a cantilever beam undergoing small strains. The aerodynamic force modification due to the beam deformation is considered (drag reconfiguration). Given the aforementioned characteristics and under the hypothesis of small displacements regime a semi-analytic solution is available.   </p><p>The beam is submitted to a uniform air wind velocity field <span>$V_a$</span>, at 20 degrees and atmospheric pressure, along axis <span>$y$</span>. Due to revolution symmetry of the problem lift <span>$c_l$</span> and torsional moment <span>$c_m$</span> coefficients are null. A drag coefficient <span>$c_d=1.2$</span> is extracted from <a href="https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/experiments-on-the-flow-past-a-circular-cylinder-at-very-high-reynolds-number/7859A6C46BF4B0F43F11F52AE1C60150">this reference</a>.  The beam has a length <span>$L$</span> and a circular solid cross section with diameter <span>$d$</span> as it is shown in the following figure: </p><img src="../../assets/nonLinearCantileverAero/ilusNonLinearStaticCantileverAero.svg" alt="general dimensions sketch" width="700"/><p>The Octave script of this example is available at : <a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/nonLinearCantileverAero/nonLinearCantileverAero.m"><img src="https://img.shields.io/badge/script-url-blue" alt="Octave script"/></a></p><h2 id="Small-displacements-2D-case"><a class="docs-heading-anchor" href="#Small-displacements-2D-case">Small displacements 2D case</a><a id="Small-displacements-2D-case-1"></a><a class="docs-heading-anchor-permalink" href="#Small-displacements-2D-case" title="Permalink"></a></h2><hr/><h3 id="Static-semi-analytic-solution"><a class="docs-heading-anchor" href="#Static-semi-analytic-solution">Static semi-analytic solution</a><a id="Static-semi-analytic-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Static-semi-analytic-solution" title="Permalink"></a></h3><p>The wind load forces of a generic cross section can be derived within the quasi-steady-theory. Considering a cross section located at <span>$x$</span>, then the projected wind velocity into the transverse deformed plane is then  <span>$V_p=V_acos(\theta_z)$</span> (the axial drag is neglected). Subsequently a drag force per unit of length <span>$F_d= \frac{1}{2} \rho d c_d ||V_p||^2$</span> with <span>$\frac{V_p}{||V_p||}$</span> direction is applied. In order to link the force <span>$F_d$</span> with the beam deflection, the uniform distributed force along <span>$y$</span> is computed as <span>$F_y=F_d.cos(\theta_z)$</span>. This leads to the following third order differential equation:</p><ul><li><p class="math-container">\[EI_{zz} \frac{\partial ^3 \theta_z}{\partial x ^3} = -q_0 c_d\cos^3(\theta_z)\]</p></li></ul><p>in which <span>$q_0 = \frac{1}{2} \rho_f d ||V_a||^2$</span> and the air density is <span>$\rho_f = 1.225$</span> kg/m<span>$^3$</span>.</p><h3 id="Numerical-solution"><a class="docs-heading-anchor" href="#Numerical-solution">Numerical solution</a><a id="Numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution" title="Permalink"></a></h3><hr/><p>Before defining the structs, the workspace is cleaned and ONSAS directory is added:</p><pre><code class="nohighlight hljs">close all, clear all ; addpath( genpath( [ pwd &#39;/../../src&#39;] ) );</code></pre><p>material and geometrical parameters are defined:</p><pre><code class="nohighlight hljs">E = 1e9 ;  nu = 0.3 ; rho = 1800 ; G = E / (2 * (1+nu)) ;
l = 10 ; d = l/100 ; J = pi * d ^ 4 / 32 ; Iyy = J / 2 ; Izz = Iyy ;  </code></pre><p>next the number of frame elements for all cases is set:</p><pre><code class="nohighlight hljs">numElements = 10 ;</code></pre><h3 id="MEBI-parameters"><a class="docs-heading-anchor" href="#MEBI-parameters">MEBI parameters</a><a id="MEBI-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters" title="Permalink"></a></h3><h3 id="materials"><a class="docs-heading-anchor" href="#materials">materials</a><a id="materials-1"></a><a class="docs-heading-anchor-permalink" href="#materials" title="Permalink"></a></h3><p>Since the example contains only one linear Euler Bernoulli element the fields of the <code>materials</code> struct will have only one entry. Although, the constitutive behavior law selected is Saint-Venant-Kirchhoff:</p><pre><code class="nohighlight hljs">materials.hyperElasModel  = &#39;linearElastic&#39; ;
materials.hyperElasParams = [ E nu ]        ;</code></pre><p>note that the use of  this linear elastic element guarantees the left hand side of the differential equation stated above.</p><h3 id="elements"><a class="docs-heading-anchor" href="#elements">elements</a><a id="elements-1"></a><a class="docs-heading-anchor-permalink" href="#elements" title="Permalink"></a></h3><p>Two different types of elements are considered, node and frames. The nodes will be assigned in the first entry (index <span>$1$</span>) and the beam at the index <span>$2$</span>. The <em>elemType</em> field is then:</p><pre><code class="nohighlight hljs">elements(1).elemType = &#39;node&#39;  ;
elements(2).elemType = &#39;frame&#39; ;</code></pre><p>The node has not cross section geometry to assign (an empty array is automatically set). The solid circular cross section is preset in ONSAS, and to load it just use:</p><pre><code class="nohighlight hljs">elements(2).elemCrossSecParams{1,1} = &#39;circle&#39; ;
elements(2).elemCrossSecParams{2,1} = d        ;</code></pre><p>Now the element aerodynmamic properties are defined. First the drag coefficient function located at the folder&#39;s example is declared into <em>userDragCoef</em> field as:</p><pre><code class="nohighlight hljs">elements(2).userDragCoef   = &#39;dragCoefCircular&#39;   ;</code></pre><p>Next the <em>elemTypeAero</em> field contains the information of the chord vector. This vector is defined first considering the orientation of the cross section set up for drag experiments. According to the revolution symmetry of the problem the chord vector orientation has no impact into drag force vector, since <span>$c_d$</span> is constant any angle of incidence. However the characteristic dimension of the circular cross section is declared into the norm of the chord vector ( first three entries of <em>elemTypeAero</em> field into <code>elements</code> struct ) as: </p><pre><code class="nohighlight hljs">numGaussPoints           = 4 ;
elements(2).elemTypeAero = [0 d 0 numGaussPoints ] ;</code></pre><p>also 4 number of integration Gauss points are employed to compute each element aerodynamic force vector.</p><h3 id="boundaryConds"><a class="docs-heading-anchor" href="#boundaryConds">boundaryConds</a><a id="boundaryConds-1"></a><a class="docs-heading-anchor-permalink" href="#boundaryConds" title="Permalink"></a></h3><p>Only one welded (6 degrees of freedom are set to zero) boundary condition (BC) is considered:</p><pre><code class="nohighlight hljs">boundaryConds(1).imposDispDofs = [ 1 2 3 4 5 6 ] ;
boundaryConds(1).imposDispVals = [ 0 0 0 0 0 0 ] ;</code></pre><h3 id="initial-Conditions"><a class="docs-heading-anchor" href="#initial-Conditions">initial Conditions</a><a id="initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#initial-Conditions" title="Permalink"></a></h3><p>Any non-homogeneous initial conditions are considered, then an empty struct is set:</p><pre><code class="nohighlight hljs">initialConds = struct() ;</code></pre><h3 id="mesh-parameters"><a class="docs-heading-anchor" href="#mesh-parameters">mesh parameters</a><a id="mesh-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#mesh-parameters" title="Permalink"></a></h3><p>The coordinates of the mesh nodes are given by the matrix:</p><pre><code class="nohighlight hljs">mesh.nodesCoords = [ (0:(numElements))&#39;*l/numElements  zeros(numElements+1,2) ] ;</code></pre><p>The connectivity is introduced using the <em>conecCell</em>. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of nodes that compose the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:</p><pre><code class="nohighlight hljs">mesh.conecCell = { } ;</code></pre><p>then the first welded node is defined with material (M) zero since nodes don&#39;t have material, the first element (E) type (the first entry of the <code>elements</code> struct), and (B) is the first entry of the the <code>boundaryConds</code> struct. For (I) no non-homogeneous initial condition is considered (then zero is used) and finally the node is assigned:</p><pre><code class="nohighlight hljs">mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1 ] ;</code></pre><p>Next the frame elements MEBI parameters are set. The frame material is the first material of <code>materials</code> struct, then <span>$1$</span> is assigned. The second entry of the <code>elements</code> struct correspond to the frame element employed, so <span>$2$</span> is set. Finally no BC and no IC is required for this element, then <span>$0$</span> is used.  Consecutive nodes build the element so then the <code>mesh.conecCell</code> is:</p><pre><code class="nohighlight hljs">for i=1:numElements,
  mesh.conecCell{ i+1,1 } = [ 1 2 0 0  i i+1 ] ;
end</code></pre><h3 id="analysisSettings"><a class="docs-heading-anchor" href="#analysisSettings">analysisSettings</a><a id="analysisSettings-1"></a><a class="docs-heading-anchor-permalink" href="#analysisSettings" title="Permalink"></a></h3><p>First the wind velocity function name is set into <em>userWindVel</em> field of <code>analysisSettings</code> struct. This will apply a external wind loads for each element with <em>elemTypeAero</em> field into the <code>elements</code> struct. The name of the wind velocity function located on the same example path is: </p><pre><code class="nohighlight hljs">analysisSettings.userWindVel = &#39;windVelNonLinearStatic&#39; ;</code></pre><p>Inside that function a linear velocity <span>$v_a = 30*t$</span> is declared. The final time will be set to <span>$1$</span> in order to achieve 30 m/s.  The geometrical non-linear effects are considered in this case to compute the aerodynamic force. As consequence the wind load forces are computed on the deformed configuration. The field  <em>geometricNonLinearAero</em> into  <code>analysisSettings</code> struct is then set to:</p><pre><code class="nohighlight hljs">analysisSettings.geometricNonLinearAero = true;</code></pre><p>note that if this boolean is not declared ONSAS will automatically assign it as true.   since this problem is static, then a N-R method is employed. The convergence of the method is accomplish with ten equal load steps. The time variable for static cases is a load factor parameter that must be configured into the <code>windVel.m</code> function. A linear profile is considered for ten equal velocity load steps as:</p><pre><code class="nohighlight hljs">analysisSettings.deltaT        =   0.1           ;
analysisSettings.finalTime     =   1             ;
analysisSettings.methodName    = &#39;newtonRaphson&#39; ;</code></pre><p>Next the maximum number of iterations per load(time) step, the residual force and the displacements tolerances are set to: </p><pre><code class="nohighlight hljs">analysisSettings.stopTolDeltau =   1e-6          ;
analysisSettings.stopTolForces =   1e-6          ;
analysisSettings.stopTolIts    =   40            ;</code></pre><h3 id="otherParams"><a class="docs-heading-anchor" href="#otherParams">otherParams</a><a id="otherParams-1"></a><a class="docs-heading-anchor-permalink" href="#otherParams" title="Permalink"></a></h3><p>The name of the problem and vtk format output are selected: </p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;nonLinearCantileverSD2D&#39;;
otherParams.plotsFormat = &#39;vtk&#39; ;</code></pre><p>ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved into matUsSD matrix:</p><pre><code class="nohighlight hljs">[matUsSD, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><h3 id="Verification"><a class="docs-heading-anchor" href="#Verification">Verification</a><a id="Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Verification" title="Permalink"></a></h3><hr/><h3 id="DifferentialEquations.jl-(reconfiguration)-solution."><a class="docs-heading-anchor" href="#DifferentialEquations.jl-(reconfiguration)-solution.">DifferentialEquations.jl (reconfiguration) solution.</a><a id="DifferentialEquations.jl-(reconfiguration)-solution.-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations.jl-(reconfiguration)-solution." title="Permalink"></a></h3><p>DiffEq.jl solves the third order ordinary differential equation for this case by executing <a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/nonLinearCantileverAero/DiffEq.jl">DiffEq.jl script</a>. Then  <a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/nonLinearCantileverAero/assembleJuliaSol.m"><code>assembleJuliaSol.m</code> script</a> function is executed to build the julia solution with <code>mesh</code> and <code>elements</code> struct as:</p><pre><code class="nohighlight hljs">[dSolJulia] = assembleJuliaSol(elements,mesh) ;</code></pre><p>Then the the relevance linear and angular displacements are extracted using:</p><pre><code class="nohighlight hljs">ydefJulia = dSolJulia(3:6:end)              ;
thetaZdefJulia = dSolJulia(6:6:end)         ;
xdefJulia = linspace(0,l,length(ydefJulia)) ;</code></pre><h3 id="Numeric-solution"><a class="docs-heading-anchor" href="#Numeric-solution">Numeric solution</a><a id="Numeric-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-solution" title="Permalink"></a></h3><p>The numerical solution is computed:</p><pre><code class="nohighlight hljs">xref    = mesh.nodesCoords(:,1)       ;
yref    = mesh.nodesCoords(:,2)       ;
zref    = mesh.nodesCoords(:,3)       ;
xdefNum = xref + matUsSD(1:6:end,end) ;
ydefNum = yref + matUsSD(3:6:end,end) ;
thetaZdefNum = matUsSD(6:6:end,end)   ;</code></pre><h3 id="Plot-verification"><a class="docs-heading-anchor" href="#Plot-verification">Plot verification</a><a id="Plot-verification-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-verification" title="Permalink"></a></h3><p>The plot parameters are:</p><pre><code class="nohighlight hljs">lw = 2 ; ms = 12 ;
labelTitle = [&#39; Validating solution with &#39; num2str(numElements) &#39; elements&#39; ] ;
axislw = 2 ; axisFontSize = 20 ; legendFontSize = 15 ; curveFontSize = 15 ;    
folderPathFigs = &#39;./output/figs/&#39; ;
mkdir(folderPathFigs) ;</code></pre><p>The linear <span>$u_y$</span> displacements verification is plotted executing:  </p><pre><code class="nohighlight hljs">fig1 = figure(1) ;
hold on, grid on
plot(xref      , ydefNum  , &#39;bo&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms+5   );
plot(xdefJulia , ydefJulia, &#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms     );
legend(&#39;y numeric SD&#39;, &#39;y semi-analytic SD&#39; )
labx=xlabel(&#39; x[m] &#39;);    laby=ylabel(&#39;y[m]&#39;);
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize, &#39;location&#39;,&#39;northWest&#39; ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
namefig1 = strcat(folderPathFigs, &#39;linDispSD.png&#39;) ;
print(fig1, namefig1,&#39;-dpng&#39;) ;</code></pre><img src="../../assets/nonLinearCantileverAero/linDispSD.png" alt="plot check angular displacements" width="500"/><p>The angular <span>$\theta_z$</span> displacements verification is plotted executing:  </p><pre><code class="nohighlight hljs">fig2 = figure(2) ;
hold on, grid on
plot(xref,      thetaZdefNum,      &#39;bo&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;, ms+5   );
plot(xdefJulia, thetaZdefJulia,    &#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms    );
legend(&#39;\theta_z numeric SD&#39;, &#39;\theta_z semi-analyitc SD&#39;)
labx=xlabel(&#39; x[m] &#39;);    laby=ylabel(&#39;Angle[rad]&#39;);
% title (labelTitle)
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize, &#39;location&#39;,&#39;northWest&#39; ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
namefig2 = strcat(folderPathFigs, &#39;angDispSD.png&#39;) ;
print(fig2, namefig2,&#39;-dpng&#39;)</code></pre><img src="../../assets/nonLinearCantileverAero/angDispSD.png" alt="plot check angular displacements" width="500"/><h2 id="Large-displacements-2D-case"><a class="docs-heading-anchor" href="#Large-displacements-2D-case">Large displacements 2D case</a><a id="Large-displacements-2D-case-1"></a><a class="docs-heading-anchor-permalink" href="#Large-displacements-2D-case" title="Permalink"></a></h2><hr/><p>Now a large displacements 2D case is solved. The solution is computed using the co-rotational beam element formulation proposed in <a href="https://www.sciencedirect.com/science/article/abs/pii/S0045782513003022">this reference</a></p><h3 id="Numerical-solution-static-case"><a class="docs-heading-anchor" href="#Numerical-solution-static-case">Numerical solution static case</a><a id="Numerical-solution-static-case-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution-static-case" title="Permalink"></a></h3><hr/><h3 id="MEBI-parameters-2"><a class="docs-heading-anchor" href="#MEBI-parameters-2">MEBI parameters</a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters-2" title="Permalink"></a></h3><hr/><h3 id="materials-2"><a class="docs-heading-anchor" href="#materials-2">materials</a><a class="docs-heading-anchor-permalink" href="#materials-2" title="Permalink"></a></h3><p>In order to reproduce large displacements results the <code>materials</code> struct is then changed to: </p><pre><code class="nohighlight hljs">materials.hyperElasModel  = &#39;1DrotEngStrain&#39; ;
materials.hyperElasParams = [ 1e8 nu ]       ;
materials.density         = rho              ;</code></pre><h3 id="elements-2"><a class="docs-heading-anchor" href="#elements-2">elements</a><a class="docs-heading-anchor-permalink" href="#elements-2" title="Permalink"></a></h3><p>The element tangent matrices of the consistent inertial force vector are taking into account by the following boolean:</p><pre><code class="nohighlight hljs">elements(2).elemTypeParams = 1 ;</code></pre><h3 id="otherParams-2"><a class="docs-heading-anchor" href="#otherParams-2">otherParams</a><a class="docs-heading-anchor-permalink" href="#otherParams-2" title="Permalink"></a></h3><p>The name of this case problem is:</p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;nonLinearCantileverLDStatic&#39; ;</code></pre><p>ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved into matUsLDStatic matrix:</p><pre><code class="nohighlight hljs">[matUsLDStatic, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><hr/><h3 id="Numerical-solution-dynamic-case"><a class="docs-heading-anchor" href="#Numerical-solution-dynamic-case">Numerical solution dynamic case</a><a id="Numerical-solution-dynamic-case-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution-dynamic-case" title="Permalink"></a></h3><hr/><p>Next a dynamic example considering large displacements motion is addressed to test the convergence of the dynamic solution disregarding any artificial damping. </p><h3 id="analysisSettings-2"><a class="docs-heading-anchor" href="#analysisSettings-2">analysisSettings</a><a class="docs-heading-anchor-permalink" href="#analysisSettings-2" title="Permalink"></a></h3><p>For such propose the wind velocity function name is now: </p><pre><code class="nohighlight hljs">analysisSettings.userWindVel = &#39;windVelNonLinearDynamic2D&#39; ;</code></pre><p>Inside that function a ramp velocity profile <span>$v_a(t) = 5*t*(t&lt;6.6) + 5*t*(t&gt;=6.6)$</span> is declared. This is an abrupt wind velocity load from 0 to <span>$7$</span> m/s in <span>$10$</span> s .</p><p>Regarding the integration time method scheme, a classic Newmark trapezoidal is set as:  </p><pre><code class="nohighlight hljs">analysisSettings.deltaT     =  1        ;
analysisSettings.finalTime  =  200      ;
analysisSettings.methodName = &#39;newmark&#39; ;
analysisSettings.alphaNM    =  0.25     ;
analysisSettings.deltaNM    =  0.5      ;</code></pre><h3 id="otherParams-3"><a class="docs-heading-anchor" href="#otherParams-3">otherParams</a><a class="docs-heading-anchor-permalink" href="#otherParams-3" title="Permalink"></a></h3><p>The name of this case problem is:</p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;nonLinearCantileverLDDynamic2D&#39; ;</code></pre><p>ONSAS software is executed for the parameters above defined and the displacement solution for each time step is saved into matUsLDDynamic matrix:</p><pre><code class="nohighlight hljs">[matUsLDDynamic, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><h3 id="Verification-2"><a class="docs-heading-anchor" href="#Verification-2">Verification</a><a class="docs-heading-anchor-permalink" href="#Verification-2" title="Permalink"></a></h3><hr/><p>The numerical dynamic convergence to the static solution is then verified . The degree of freedom selected for such task is <span>$u_y(t)$</span> of node A. </p><h3 id="Static-solution."><a class="docs-heading-anchor" href="#Static-solution.">Static solution.</a><a id="Static-solution.-1"></a><a class="docs-heading-anchor-permalink" href="#Static-solution." title="Permalink"></a></h3><p>Extract static numerical time history displacements <span>$u_y$</span> of node A. First the selected degree of freedom is:</p><pre><code class="nohighlight hljs">nodeA = numElements + 1                ;
relativeDofUyA = 3                     ;
dofUyA = (nodeA -1)*6 + relativeDofUyA ; </code></pre><p>then node A <span>$u_y$</span> time history accessed by:</p><pre><code class="nohighlight hljs">UyAStaticSol = matUsLDStatic(dofUyA,:) ;</code></pre><h3 id="Dynamic-solution."><a class="docs-heading-anchor" href="#Dynamic-solution.">Dynamic solution.</a><a id="Dynamic-solution.-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-solution." title="Permalink"></a></h3><p>Extract dynamic numerical solution as follows:</p><pre><code class="nohighlight hljs">UyADynamicSol = matUsLDDynamic(dofUyA,:) ;</code></pre><p>next, the time vector is given by:</p><pre><code class="nohighlight hljs">timVecLD = linspace(0, analysisSettings.finalTime, size(matUsLDDynamic,2) ) ;</code></pre><h3 id="Verification-Plot"><a class="docs-heading-anchor" href="#Verification-Plot">Verification Plot</a><a id="Verification-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Verification-Plot" title="Permalink"></a></h3><p>Create folder to save figures</p><pre><code class="nohighlight hljs">folderFigs = strcat(&#39;./output/&#39;, &#39;figs/&#39;) ;
mkdir(folderFigs) ;</code></pre><p>The linear <span>$u_y$</span> displacements verification of node  A is finally plotted executing:  </p><pre><code class="nohighlight hljs">fig3 = figure(3) ;
hold on,  grid on
% legend first point plot
plot(timVecLD(1), UyADynamicSol(1),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
% static solution plot
plot(timVecLD   , UyAStaticSol(end)*ones(length(timVecLD)), &#39;k:&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms     );
% markers plot
plot(timVecLD(1:8:end), UyADynamicSol(1:8:end),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;none&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
% continium line plot
plot(timVecLD, UyADynamicSol,...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;, &#39;marker&#39;, &#39;none&#39;)
legend(&#39;dynamic LD&#39;, &#39;static LD&#39; )
labx=xlabel(&#39;x[m]&#39;);    laby=ylabel(&#39;y[m]&#39;);
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize, &#39;location&#39;,&#39;northEast&#39; ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
namefig3 = strcat(folderPathFigs, &#39;uyA.png&#39;) ;
print(fig3, namefig3,&#39;-dpng&#39;) ;</code></pre><img src="../../assets/nonLinearCantileverAero/uyA.png" alt="plot check angular displacements" width="500"/><h2 id="Large-displacements-3D-case"><a class="docs-heading-anchor" href="#Large-displacements-3D-case">Large displacements 3D case</a><a id="Large-displacements-3D-case-1"></a><a class="docs-heading-anchor-permalink" href="#Large-displacements-3D-case" title="Permalink"></a></h2><hr/><p>A large displacements dynamic 3D case is presented as follows. This example is inspired on Vortex shedding  exposed at <a href="https://www.youtube.com/watch?v=Lf9Ffj5rGh8&amp;ab_channel=FrederickGosselin"><img src="https://img.shields.io/badge/script-url-blue" alt="Youtbue Video"/></a></p><h3 id="MEBI-parameters-3"><a class="docs-heading-anchor" href="#MEBI-parameters-3">MEBI parameters</a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters-3" title="Permalink"></a></h3><hr/><h3 id="materials-3"><a class="docs-heading-anchor" href="#materials-3">materials</a><a class="docs-heading-anchor-permalink" href="#materials-3" title="Permalink"></a></h3><p>In order to reproduce large displacements results the <code>materials</code> struct is then changed to: </p><pre><code class="nohighlight hljs">materials.hyperElasParams = [ 1e8 nu ]       ;</code></pre><h3 id="analysisSettings-3"><a class="docs-heading-anchor" href="#analysisSettings-3">analysisSettings</a><a class="docs-heading-anchor-permalink" href="#analysisSettings-3" title="Permalink"></a></h3><p>Regarding the integration time method scheme, a classic <span>$\alpha-HHT$</span> method is employed. This method is more stable numerically than Newmark, the keen reader is refereed to <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/eqe.4290050306">this reference</a>:</p><pre><code class="nohighlight hljs">analysisSettings.methodName = &#39;alphaHHT&#39;;
analysisSettings.alphaHHT   =   -0.05   ;</code></pre><p>the simulation time is defined such that:  </p><pre><code class="nohighlight hljs">analysisSettings.deltaT     =  .2  ;
analysisSettings.finalTime  =  120 ;</code></pre><p>The emulation of the vortex shedding vibration is generated by a synthetic wind velocity composed by two sinusoidal velocities. A low frequency <span>$Vy_a$</span> along the mean flow direction <span>$y$</span> and then a high frequency component  <span>$Vz_a$</span> along <span>$z$</span>. The high frequency component is selected to produce resonance effects between the flow and the beam, thus the high frequency velocity is selected equal to the first mode bending:</p><pre><code class="nohighlight hljs">freqBendingFirstMode = (1.875)^2 * sqrt( materials.hyperElasParams(1) * Iyy / (materials.density * (pi * d^4 / 4) * l^4) ) ;
analysisSettings.userWindVel = &#39;windVelNonLinearDynamic3D&#39; ;</code></pre><p>The velocity function componentes are assembled:</p><pre><code class="nohighlight hljs">timeVecLD3d = linspace(0,analysisSettings.finalTime, ceil(analysisSettings.finalTime / analysisSettings.deltaT + 1) ) ;
windVelY = [] ; windVelZ = [] ;
for timeIndex = timeVecLD3d
    windVelVecTimeIndex = feval(analysisSettings.userWindVel, 0, timeIndex) ;
    windVelY = [windVelY windVelVecTimeIndex(2) ] ;
    windVelZ = [windVelZ windVelVecTimeIndex(3) ] ;
end</code></pre><h3 id="otherParams-4"><a class="docs-heading-anchor" href="#otherParams-4">otherParams</a><a class="docs-heading-anchor-permalink" href="#otherParams-4" title="Permalink"></a></h3><p>The name of this case problem is:</p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;nonLinearCantileverLD3D&#39; ;</code></pre><p>ONSAS software is executed for the parameters above defined and the displacement solution for each time step is saved into matUsLD3D matrix:</p><pre><code class="nohighlight hljs">[matUsLD3D, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><h3 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h3><p>The wind velocity profile implemented is plotted executing:  </p><pre><code class="nohighlight hljs">fig4 = figure(4) ;
hold on,  grid on
% legend first point plot
plot(timeVecLD3d(1), windVelY(1),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
plot(timeVecLD3d(1), windVelZ(1),...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;^&#39;)
% markers plot
plot(timeVecLD3d(1:10:end), windVelY(1:10:end),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;none&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
plot(timeVecLD3d(1:17:end), windVelZ(1:17:end),...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;none&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;^&#39;)
% continium line plot
plot(timeVecLD3d, windVelY,...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;, &#39;marker&#39;, &#39;none&#39;)
plot(timeVecLD3d, windVelZ,...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;, &#39;marker&#39;, &#39;none&#39;)
legend(&#39;Va_y&#39;, &#39;Va_z&#39; )
labx=xlabel(&#39;t[s]&#39;);    laby=ylabel(&#39;V_a[m/s]&#39;);
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize, &#39;location&#39;,&#39;northEast&#39; ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
namefig4 = strcat(folderPathFigs, &#39;windVel3D.png&#39;) ;
axis([0,50])
print(fig4, namefig4,&#39;-dpng&#39;) ;</code></pre><img src="../../assets/nonLinearCantileverAero/windVel3D.png" alt="plot check angular displacements" width="500"/><p>Then <span>$u_y$</span> of node A  is computed using:  </p><pre><code class="nohighlight hljs">UyADynamicSol3D = matUsLD3D(dofUyA,:) ;</code></pre><p>analogosuly <span>$u_z$</span> of A node is:  </p><pre><code class="nohighlight hljs">UzADynamicSol3D = matUsLD3D(dofUyA + 2,:) ;</code></pre><p>Open figure and plot</p><pre><code class="nohighlight hljs">fig5 = figure(5) ;
hold on,  grid on
% legend first point plot uy 
plot(timeVecLD3d(1), UyADynamicSol3D(1),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
% legend first point plot uz
plot(timeVecLD3d(1), UzADynamicSol3D(1),...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;^&#39;)
% markers plot uy
plot(timeVecLD3d(1:13:end), UyADynamicSol3D(1:13:end),...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;none&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;o&#39;)
% continium line plot uy
plot(timeVecLD3d, UyADynamicSol3D,...
     &#39;color&#39;, &#39;b&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;, &#39;marker&#39;, &#39;none&#39;)
% markers plot uz
plot(timeVecLD3d(1:23:end), UzADynamicSol3D(1:23:end),...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;none&#39;,&#39;markersize&#39;, ms, &#39;marker&#39;, &#39;^&#39;)
% continium line plot uz
plot(timeVecLD3d, UzADynamicSol3D,...
     &#39;color&#39;, &#39;r&#39;, &#39;linewidth&#39;, lw, &#39;linestyle&#39;, &#39;-&#39;, &#39;marker&#39;, &#39;none&#39;)
legend(&#39;U_y node A&#39;, &#39;U_z node A&#39; )
labx=xlabel(&#39;x[m]&#39;);    laby=ylabel(&#39;Dispalcements[m]&#39;);
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize, &#39;location&#39;,&#39;northEast&#39; ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
namefig5 = strcat(folderPathFigs, &#39;uA3D.png&#39;) ;
print(fig5, namefig5,&#39;-dpng&#39;) ;</code></pre><img src="../../assets/nonLinearCantileverAero/uA3D.png" alt="plot check angular displacements" width="500"/><p>Finally a GIF to illustrate the motion amplitude is subsequently presented:</p><img src="../../assets/nonLinearCantileverAero/cyilindricalCantBeam3D.gif" alt="plot check angular displacements" width="500"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../staticAeroLinearCantilever/">« Linear static aerodynamic cantilever beam</a><a class="docs-footer-nextpage" href="../../howtouse/install/">Installation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 28 March 2022 13:02">Monday 28 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
