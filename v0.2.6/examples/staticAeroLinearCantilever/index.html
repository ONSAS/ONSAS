<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear static aerodynamic cantilever beam · ONSAS.m</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ONSAS.m logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ONSAS.m</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Learning by examples</span><ul><li><a class="tocitem" href="../staticVonMisesTruss/">Static Von-Mises Truss</a></li><li><a class="tocitem" href="../springMass/">Spring-mass system</a></li><li><a class="tocitem" href="../uniaxialExtension/">Uniaxial extension</a></li><li><a class="tocitem" href="../cantileverBeam/">Cantilever Beam</a></li><li><a class="tocitem" href="../semiSphereWithInclusion/">Solid with inclusion</a></li><li class="is-active"><a class="tocitem" href>Linear static aerodynamic cantilever beam</a><ul class="internal"><li><a class="tocitem" href="#Analytic-solution"><span>Analytic solution</span></a></li><li><a class="tocitem" href="#Numerical-solution"><span>Numerical solution</span></a></li><li><a class="tocitem" href="#Verification"><span>Verification</span></a></li></ul></li><li><a class="tocitem" href="../nonLinearCantileverAero/">Non-linear aerodynamic cantilever beam</a></li></ul></li><li><span class="tocitem">User guide</span><ul><li><a class="tocitem" href="../../howtouse/install/">Installation</a></li><li><a class="tocitem" href="../../howtouse/creatingModels/">Creating Models</a></li><li><a class="tocitem" href="../../theory/references/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning by examples</a></li><li class="is-active"><a href>Linear static aerodynamic cantilever beam</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear static aerodynamic cantilever beam</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ONSAS/ONSAS.m/blob/master/docs/src/examples/staticAeroLinearCantilever.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Aerodynamic-linear-static-cantilever-beam-example"><a class="docs-heading-anchor" href="#Aerodynamic-linear-static-cantilever-beam-example">Aerodynamic linear static cantilever beam example</a><a id="Aerodynamic-linear-static-cantilever-beam-example-1"></a><a class="docs-heading-anchor-permalink" href="#Aerodynamic-linear-static-cantilever-beam-example" title="Permalink"></a></h1><hr/><p>In this tutorial, the linear static cantilever aero example and how to address the problem using ONSAS is described. The aim of this example is to validate aerodynamic steady and uniform wind loads applied to a cantilever beam undergoing small displacements and strains. The aerodynamic force variation due to the beam deformation is not considered. Under this hypothesis a symbolic solution is available. </p><p>The beam is submitted to a uniform air wind velocity field <span>$v_a$</span> at 20 degrees and atmospheric pressure along axis <span>$z$</span>, and because of an ice accretion on the frame cross section, lift and drag forces are induced. The lift and drag forces are characterized with their respective aerodynamic coefficients <span>$c_d$</span> and <span>$c_l$</span> are based on <a href="http://pure-oai.bham.ac.uk/ws/portalfiles/portal/44736207/He_Macdonald_2017_Aeroelastic_stability_of_a_3DOF_system_based_on_quasi_steady_theory_with_reference_to_inertial_coupling.pdf">this reference</a>.  The beam has a length <span>$L$</span> and a hollow cylindrical cross section with <span>$d_{ext}$</span> and a thickness <span>$b$</span> as it is shown in Fig.1. </p><img src="../../assets/linearStaticCantileverAero/ilusLinearStaticCantileverAero.svg" alt="plot check angular displacements" width="700"/><p>The Octave script of this example is available at : <a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/linearStaticCantileverAero/staticAeroLinearCantilever.m"><img src="https://img.shields.io/badge/script-url-blue" alt="Octave script"/></a></p><h2 id="Analytic-solution"><a class="docs-heading-anchor" href="#Analytic-solution">Analytic solution</a><a id="Analytic-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Analytic-solution" title="Permalink"></a></h2><hr/><p>The static solution is obtained within the static Euler-Bernoulli beam theory,thus the angular rotations field are: </p><ul><li><p class="math-container">\[\theta_z(x)= \frac{qy}{6 EI_{zz}} \left( (x-L)^3 +L^3 \right)\]</p></li></ul><p>and</p><ul><li><p class="math-container">\[\theta_y(x)= \frac{qz}{6 EI_{yy}} \left( (x-L)^3 +L^3 \right)\]</p></li></ul><p>in which <span>$q = 1/2 \rho v_a^2 d_{ext}$</span>, <span>$q_z = q c_d$</span> and <span>$q_y = q c_l$</span>.</p><p>Integrating respect to x the angular rotations stated above derives to the following expressions: </p><ul><li><p class="math-container">\[u_y(x)= -\frac{qy}{24 EI_{zz}} \left( 6L^2x^2 - 4Lx^3 + x^4 \right)\]</p></li></ul><p>and</p><ul><li><p class="math-container">\[u_z(x)= -\frac{qz}{24 EI_{yy}} \left( 6L^2x^2 - 4Lx^3 + x^4 \right)\]</p></li></ul><p>in which <span>$q = 1/2 \rho v_a^2 d_{ext}$</span>, <span>$q_z = q c_d$</span> and <span>$q_y = q c_l$</span>.</p><h2 id="Numerical-solution"><a class="docs-heading-anchor" href="#Numerical-solution">Numerical solution</a><a id="Numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution" title="Permalink"></a></h2><hr/><p>The Octave script of this example is available at <a href="https://github.com/ONSAS/ONSAS.m/blob/master/examples/linearStaticCantileverAero/onsasExample_staticAeroLinearCantilever.m">this url</a>.  Before defining the structs, the workspace is cleaned and the ONSAS directory is added:</p><pre><code class="nohighlight hljs">close all, clear all ; addpath( genpath( [ pwd &#39;/../../src&#39;] ) );</code></pre><p>The material linear <span>$E$</span> and shear <span>$G$</span> Elastic modulus and the Poisson&#39;s ratio <span>$\nu$</span> are:</p><pre><code class="nohighlight hljs">E = 70e9 ;  nu = 0.3 ; G = E / (2 * (1+nu)) ;</code></pre><p>Geometrical dimensions sketched in Fig 1 are:</p><pre><code class="nohighlight hljs">l = 20 ; dext = .5 ;  b = 1e-3  ; dint  = dext - 2*b    ;
A = pi * (dext^2 - dint^2) / 4  ;
J = pi * (dext^4 - dint^4) / 32 ; Iyy = J/2 ; Izz = Iyy ;</code></pre><p>the number of elements employed to discriteze the beam is:</p><pre><code class="nohighlight hljs">numElements = 10 ;</code></pre><h3 id="MEBI-parameters"><a class="docs-heading-anchor" href="#MEBI-parameters">MEBI parameters</a><a id="MEBI-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#MEBI-parameters" title="Permalink"></a></h3><h3 id="materials"><a class="docs-heading-anchor" href="#materials">materials</a><a id="materials-1"></a><a class="docs-heading-anchor-permalink" href="#materials" title="Permalink"></a></h3><p>Since the example contains only one linear Euler Bernoulli element the fields of the <code>materials</code> struct will have only one entry. Although, the constitutive behavior law selected is Saint-Venant-Kirchhoff:</p><pre><code class="nohighlight hljs">materials.hyperElasModel  = &#39;linearElastic&#39; ;
materials.hyperElasParams = [ E nu ]        ;</code></pre><h3 id="elements"><a class="docs-heading-anchor" href="#elements">elements</a><a id="elements-1"></a><a class="docs-heading-anchor-permalink" href="#elements" title="Permalink"></a></h3><p>Two different types of elements are considered, node and frames. The nodes will be assigned in the first entry (index <span>$1$</span>) and the beam at the index <span>$2$</span>. The <em>elemType</em> field is then:</p><pre><code class="nohighlight hljs">elements(1).elemType = &#39;node&#39;  ;
elements(2).elemType = &#39;frame&#39; ;</code></pre><p>The node has not cross section geometry to assign (an empty array is automatically set). Since the frame element has no implemented a hollow cylindrical cross section, then a <code>&#39;generic&#39;</code> cross-section dimensions in <span>$y$</span> and <span>$z$</span> directions is used. Thus the <em>elemCrossSecParams</em> field is:</p><pre><code class="nohighlight hljs">elements(2).elemCrossSecParams{1,1} = &#39;generic&#39; ;
elements(2).elemCrossSecParams{2,1} = [ A J Iyy Izz ] ;</code></pre><p>Now the parameters to include aerodynamic forces automatically on the frame element are defined. First the drag and lift cross section functions are set in concordance with the function names located at the same example folder. Thus the userDragCoef_  userLiftCoef_ <em>momentCoefFunction</em> fields are:</p><pre><code class="nohighlight hljs">elements(2).userDragCoef   = &#39;dragCoefFunction&#39;   ;
elements(2).userLiftCoef   = &#39;liftCoefFunction&#39;   ;</code></pre><p>Next the <em>elemTypeAero</em> field contain the information of the chord vector. This vector is defined first considering the orientation of the cross section set up in lift, drag and moment experiments, and then how that cross section is located for the example. In this case the orientation of the chord vector is along <span>$y$</span>. In general note that the chord vector <span>$t_{ch}$</span> must be given in reference (non canonical configurations). In this example the cable is oriented along <span>$y$</span> so the direction will be <span>$[0~1~0]$</span> as it is shown in Fig 1. Also the length of the chord is added to the norm of the chord vector, for cylindrical cantilever beams is <span>$d_{ext}$</span>. All this information is added into <em>elemTypeAero</em> field of <code>elements</code> struct such that:</p><pre><code class="nohighlight hljs">numGaussPoints  = 4 ; 
elements(2).elemTypeAero   = [0 dext 0 numGaussPoints];</code></pre><p>in which 4 Gauss integration points are employed to compute the aerodynamic force. This value is enough in most cases. </p><h3 id="boundaryConds"><a class="docs-heading-anchor" href="#boundaryConds">boundaryConds</a><a id="boundaryConds-1"></a><a class="docs-heading-anchor-permalink" href="#boundaryConds" title="Permalink"></a></h3><p>Only one welded (6 degrees of freedom are set to zero) boundary condition (BC) is considered:</p><pre><code class="nohighlight hljs">boundaryConds(1).imposDispDofs = [ 1 2 3 4 5 6 ] ;
boundaryConds(1).imposDispVals = [ 0 0 0 0 0 0 ] ;</code></pre><h3 id="initial-Conditions"><a class="docs-heading-anchor" href="#initial-Conditions">initial Conditions</a><a id="initial-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#initial-Conditions" title="Permalink"></a></h3><p>Any non-homogeneous initial condition (IC) are set for this case, then an empty struct is used:</p><pre><code class="nohighlight hljs">initialConds = struct() ;</code></pre><h3 id="mesh-parameters"><a class="docs-heading-anchor" href="#mesh-parameters">mesh parameters</a><a id="mesh-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#mesh-parameters" title="Permalink"></a></h3><p>The coordinates of the mesh nodes are given by the matrix:</p><pre><code class="nohighlight hljs">mesh.nodesCoords = [ (0:(numElements))&#39;*l/numElements  zeros(numElements+1,2) ] ;</code></pre><p>The connectivity is introduced using the <em>conecCell</em>. Each entry of the cell contains a vector with the four indexes of the MEBI parameters, followed by the indexes of nodes that compose the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:</p><pre><code class="nohighlight hljs">mesh.conecCell = { } ;</code></pre><p>then the first welded node is defined with material (M) zero since nodes don&#39;t have material, the first element (E) type (the first entry of the <code>elements</code> struct), and (B) is the first entry of the the <code>boundaryConds</code> struct. For (I) no non-homogeneous initial condition is considered (then zero is used) and finally the node is assigned:</p><pre><code class="nohighlight hljs">mesh.conecCell{ 1, 1 } = [ 0 1 1 0  1 ] ;</code></pre><p>Next the frame elements MEBI parameters are set. The frame material is the first material of <code>materials</code> struct, then <span>$1$</span> is assigned. The second entry of the <code>elements</code> struct correspond to the frame element employed, so <span>$2$</span> is set. Finally no BC and no IC is required for this element, then <span>$0$</span> is used.  Consecutive nodes build the element so then the <code>mesh.conecCell</code> is:</p><pre><code class="nohighlight hljs">for i=1:numElements,
  mesh.conecCell{ i+1,1 } = [ 1 2 0 0  i i+1 ] ;
end</code></pre><h3 id="analysisSettings"><a class="docs-heading-anchor" href="#analysisSettings">analysisSettings</a><a id="analysisSettings-1"></a><a class="docs-heading-anchor-permalink" href="#analysisSettings" title="Permalink"></a></h3><p>First the wind velocity function name is set into <em>userWindVel</em> field of <code>analysisSettings</code> struct. This will apply a external wind loads for each element with <em>elemTypeAero</em> field into the <code>elements</code> struct. The name of the wind velocity function located on the same example path is: </p><pre><code class="nohighlight hljs">analysisSettings.userWindVel = &#39;windVel&#39; ;</code></pre><p>The geometrical non-linear effects are not considered in this case to compute the aerodynamic force. As consequence the wind load forces are computed on the reference configuration, and remains constant during the beam deformation. The field  <em>geometricNonLinearAero</em> into  <code>analysisSettings</code> struct is then set to:</p><pre><code class="nohighlight hljs">analysisSettings.geometricNonLinearAero = false;</code></pre><p>since this problem is static, then a N-R method is employed. The convergence of the method is accomplish with ten equal load steps. The time variable for static cases is a load factor parameter that must be configured into the <code>windVel.m</code> function. A linear profile is considered for ten equal velocity load steps as:</p><pre><code class="nohighlight hljs">analysisSettings.deltaT        =   0.1           ;
analysisSettings.finalTime     =   1             ;
analysisSettings.methodName    = &#39;newtonRaphson&#39; ;</code></pre><p>Next the maximum number of iterations per load(time) step, the residual force and the displacements tolerances are set to: </p><pre><code class="nohighlight hljs">analysisSettings.stopTolDeltau =   1e-6          ;
analysisSettings.stopTolForces =   1e-6          ;
analysisSettings.stopTolIts    =   10            ;</code></pre><h3 id="otherParams"><a class="docs-heading-anchor" href="#otherParams">otherParams</a><a id="otherParams-1"></a><a class="docs-heading-anchor-permalink" href="#otherParams" title="Permalink"></a></h3><p>The name of the problem and vtk format output are selected: </p><pre><code class="nohighlight hljs">otherParams.problemName = &#39;aeroLinStaticCantilever&#39;;
otherParams.plotsFormat = &#39;vtk&#39; ;</code></pre><p>The ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved as:</p><pre><code class="nohighlight hljs">[matUs, ~] = ONSAS( materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams ) ;</code></pre><h2 id="Verification"><a class="docs-heading-anchor" href="#Verification">Verification</a><a id="Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Verification" title="Permalink"></a></h2><hr/><p>This example validation is ascertained comparing analytical and numerical solutions.</p><h3 id="Symbolic-solution"><a class="docs-heading-anchor" href="#Symbolic-solution">Symbolic solution</a><a id="Symbolic-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-solution" title="Permalink"></a></h3><p>For such propose the angle of incidence and the wind properties are computed as:</p><pre><code class="nohighlight hljs">% air density is:
rhoAire = 1.2 ;
% then characteristic dimension is extracted executing: 
dimCaracteristic = norm(elements(2).elemTypeAero (1:3) ) ;
% the angle of attack is: 
betaRel = acos(dot(elements(2).elemTypeAero( 1:3 ) , [0 0 1] ));
% the wind velocity is:
windVel = feval(analysisSettings.userWindVel, betaRel, analysisSettings.finalTime) ;
% the drag, lift and eventually moment coef are:
if isfield(elements(2), &#39;userDragCoef&#39;)
  c_d = feval(elements(2).userDragCoef, betaRel);
else
  c_d = 0;
end
if isfield(elements(2), &#39;userLiftCoef&#39;)
  c_l = feval(elements(2).userLiftCoef, betaRel);
else
  c_l = 0;
end</code></pre><p>Then the dynamic pressures <span>$q_0$</span> defined above are expressed such that: </p><pre><code class="nohighlight hljs">q = 1/2 * rhoAire * (windVel(3)^2 + windVel(2)^2) ;</code></pre><p>next the loads per unit of length are  </p><pre><code class="nohighlight hljs">qz = q * c_d * dimCaracteristic ; qy = q * c_l * dimCaracteristic ; </code></pre><p>then an analytic x vector to evaluate the deformed analytic solution is build as </p><pre><code class="nohighlight hljs">sizeAnalyticX = 100 ;
xAnalytic = linspace(0,l,sizeAnalyticX)&#39; ;</code></pre><p>The linear displacements symbolic solutions are:</p><pre><code class="nohighlight hljs">ydefAnalytic = @(x) -qy / (24*E*Izz) * (6*l^2*x.^2 -4*l*x.^3+x.^4) ;
zdefAnalytic = @(x) qz  / (24*E*Izz) * (6*l^2*x.^2 -4*l*x.^3+x.^4) ;</code></pre><p>then the angular displacements symbolic solutions are:</p><pre><code class="nohighlight hljs">thetaYAnalytic = @(x) -qz  / (6*E*Iyy) * (3* l^2 * x -3*l*x.^2+x.^3) ;
thetaZAnalytic = @(x) -qy  / (6*E*Izz) * (3* l^2 * x -3*l*x.^2+x.^3) ;</code></pre><h3 id="Numeric-solution"><a class="docs-heading-anchor" href="#Numeric-solution">Numeric solution</a><a id="Numeric-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-solution" title="Permalink"></a></h3><p>The numerical solution is extracted:</p><pre><code class="nohighlight hljs">xref    = mesh.nodesCoords(:,1)     ;
yref    = mesh.nodesCoords(:,2)     ;
zref    = mesh.nodesCoords(:,3)     ;
ydefNum = yref + matUs(3:6:end,end) ;
zdefNum = zref + matUs(5:6:end,end) ;
thetaYdefNum = matUs(4:6:end,end)   ;
thetaZdefNum = matUs(6:6:end,end)   ;</code></pre><h3 id="Verification-boolean"><a class="docs-heading-anchor" href="#Verification-boolean">Verification boolean</a><a id="Verification-boolean-1"></a><a class="docs-heading-anchor-permalink" href="#Verification-boolean" title="Permalink"></a></h3><p>The verification boolean is computed as <span>$||U_n - U_a || / || U_a || &lt; 10^{-1}$</span></p><pre><code class="nohighlight hljs">verifBoolean = norm( [ ydefNum - ydefAnalytic(xref); thetaYdefNum - thetaYAnalytic(xref); zdefNum - zdefAnalytic(xref); thetaZdefNum - thetaZAnalytic(xref) ] ) ...
                &lt;  1e-1 * norm( [ ydefAnalytic(xref);  thetaYAnalytic(xref);  zdefAnalytic(xref); thetaZAnalytic(xref) ] )  ;      </code></pre><h3 id="Plot-verification"><a class="docs-heading-anchor" href="#Plot-verification">Plot verification</a><a id="Plot-verification-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-verification" title="Permalink"></a></h3><p>The plot parameters are:</p><pre><code class="nohighlight hljs">lw = 5 ; ms = 8 ;
labelTitle= [&#39; Validating solution with &#39; num2str(numElements) &#39; elements&#39; ];
axislw = 2 ; axisFontSize = 20 ; legendFontSize = 15 ; curveFontSize = 15 ;       </code></pre><p>The linear displacements verification is plotted using:  </p><pre><code class="nohighlight hljs">figure(1)
hold on, grid on
plot(xref      , zdefNum                ,&#39;ro&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms) ;
plot(xAnalytic , zdefAnalytic(xAnalytic),&#39;r-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms) ;
plot(xref      , ydefNum                ,&#39;bo&#39; , &#39;linewidth&#39;, lw,&#39;markersize&#39;  , ms) ;
plot(xAnalytic , ydefAnalytic(xAnalytic),&#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39; , ms) ;
legend(&#39;z_n&#39;, &#39;z_a&#39;,  &#39;y_n&#39;, &#39;y_a&#39;, &#39;location&#39;, &#39;north&#39;)
labx=xlabel(&#39; x (m)&#39;);    laby=ylabel(&#39;Displacements (m)&#39;);
title (labelTitle)
set(legend, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, legendFontSize ) ;
set(gca, &#39;linewidth&#39;, axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx, &#39;FontSize&#39;, axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
print(&#39;./output/linearDisp.png&#39;)</code></pre><img src="../../assets/linearStaticCantileverAero/verifLinearStaticCantileverAero1.png" alt="plot check linear displacements" width="500"/><p>The angular displacements verification is plotted using:  </p><pre><code class="nohighlight hljs">figure(2)
hold on, grid on
plot(xref      , rad2deg(thetaYdefNum)              , &#39;ro&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xAnalytic , rad2deg(thetaYAnalytic(xAnalytic)) , &#39;r-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xref      , rad2deg(thetaZdefNum)              , &#39;bo&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
plot(xAnalytic , rad2deg(thetaZAnalytic(xAnalytic)) , &#39;b-&#39; , &#39;linewidth&#39;, lw, &#39;markersize&#39;, ms) ;
legend(&#39;\theta y_n&#39;, &#39;\theta y_a&#39;, &#39;\theta z_n&#39;, &#39;\theta z_a&#39;,  &#39;location&#39;, &#39;eastoutside&#39; )
labx=xlabel(&#39; x (m)&#39;); laby=ylabel(&#39;Angle (º)&#39;);
title (labelTitle)
set(legend, &#39;linewidth&#39; , axislw, &#39;fontsize&#39;, legendFontSize) ;
set(gca   , &#39;linewidth&#39; , axislw, &#39;fontsize&#39;, curveFontSize ) ;
set(labx  , &#39;FontSize&#39;  , axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize) ;
print(&#39;./output/angDisp.png&#39;)</code></pre><img src="../../assets/linearStaticCantileverAero/verifLinearStaticCantileverAero2.png" alt="plot check angular displacements" width="500"/><p>The 3D deformed configuration is plotted executing:  </p><pre><code class="nohighlight hljs">figure
hold on, grid on
plot3(xref     , yref                    , zref                   ,&#39;k-&#39; , &#39;linewidth&#39;, lw + 300, &#39;markersize&#39;, ms+200 );
plot3(xAnalytic, ydefAnalytic(xAnalytic) , zdefAnalytic(xAnalytic),&#39;r-&#39; , &#39;linewidth&#39;, lw      , &#39;markersize&#39;, ms     );
plot3(xref     , ydefNum                 , zdefNum                ,&#39;bo&#39; , &#39;linewidth&#39;, lw      , &#39;markersize&#39;, ms     );
legend(&#39;Reference config&#39;   , &#39;Analytic def config&#39; , &#39;Numerical def config&#39;, &#39;location&#39;,&#39;northEast&#39;)
labx=xlabel( &#39;x (m)&#39; )      ; laby=ylabel(&#39;y(m)&#39;)   ; labz=zlabel(&#39;z(m)&#39;)  ;
set(legend, &#39;linewidth&#39;, axislw       , &#39;fontsize&#39;  , legendFontSize )     ;
set(gca   , &#39;linewidth&#39;, axislw       , &#39;fontsize&#39;  , curveFontSize  )     ;
set(labx  , &#39;FontSize&#39; , axisFontSize); set(laby, &#39;FontSize&#39;, axisFontSize); set(labz, &#39;FontSize&#39;, axisFontSize) ;
view([0.5 +0.5 -1])
print(&#39;./output/def.png&#39;,&#39;-dpng&#39;)    </code></pre><img src="../../assets/linearStaticCantileverAero/verifLinearStaticCantileverAero3.png" alt="plot check deformed configurations" width="500"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../semiSphereWithInclusion/">« Solid with inclusion</a><a class="docs-footer-nextpage" href="../nonLinearCantileverAero/">Non-linear aerodynamic cantilever beam »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Monday 28 March 2022 13:02">Monday 28 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
