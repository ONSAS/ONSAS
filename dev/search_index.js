var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"(Bathe, 2014) Klaus-Jurgen Bathe.  Finite Element Procedures . 2014.\n(Bazzano and Pérez Zerpa, 2017) J. B. Bazzano and J. Perez Zerpa.  Introducción al Análisis No Lineal de Estructuras. 2017.\n(Battini and Pacoste, 2002) Co-rotational beam elements with warping effects in instability problems, Computer Methods in Applied Mechanics and Engineering, 191 (17-18). 2020.\n(Holzapfel, 2000) Nonlinear Solid Mechanics, A continuum approach for Engineering, 2000, Wiley.","category":"section"},{"location":"examples/springMass/#Spring-mass-damper-system-example","page":"Spring-mass system","title":"Spring-mass-damper system example","text":"(Image: Octave script)","category":"section"},{"location":"examples/springMass/#ODE-System-definition","page":"Spring-mass system","title":"ODE System definition","text":"In this example a simple spring-mass-damper system is considered. This simple problem is used to validate different implementations of truss and frame elements submitted to dynamic loads.\n\n<img src=\"../../assets/springMassSystem.svg\" alt=\"spring-mass diagram\" width=\"800\"/>","category":"section"},{"location":"examples/springMass/#Analytic-solution","page":"Spring-mass system","title":"Analytic solution","text":"The analytical solution is based on chapter 3 from Dynamics of Structures by Ray W. Clough and Joseph Penzien, Third Edition, 2003. The analytical solution of the problem is given by:\n\nu(t) =\nleft( A_c cos( omega_D  t ) + B sin( omega_D t )  right) e^ -xi omega_N t  +\nG_1  cos( baromega t ) + G_2 sin( baromega t )\n\nwhere the notation and the parameters interpretation can be seen in the cited reference.\n\nA set of numerical parameters must be defined to compute the analytic solution.\n\nWe start as all models, clearing the workspace and adding the ONSAS path to the work path.\n\nclose all;\nif ~strcmp(getenv('TESTS_RUN'), 'yes')\n  clear all;\nend\naddpath(genpath([pwd '/../../src']));\n\nThe following numeric parameters are considered.\n\nk    = 39.47; % spring constant\nc    = 2; % damping parameter\nm    = 1; % mass of the system\np0   = 40; % amplitude of applied load\nu0   = 0.1; % initial displacement\ndu0  = 0.0; % initial velocity\n\nThen other parameters are computed:\n\nomegaN  = sqrt(k / m); % the natural frequency\nxi      = c / m  / (2 * omegaN);\nfreq    = omegaN / (2 * pi);\nTN      = 2 * pi / omegaN;\ndtCrit  = TN / pi;\n\nThe frequency of the sinusoidal external force is set as:\n\nomegaBar = 4 * omegaN;\n\nThe analytic solution can be computed for specific cases as follows:\n\nif (c == 0) && (p0 == 0) % free undamped solution\n  myAnalyticFunc = @(t)   (u0 * cos(omegaN * t));\nelse                     % other cases solution\n  beta   = omegaBar / omegaN;\n  omegaD = omegaN * sqrt(1 - xi^2); % forced and damped\n  G1 = (p0 / k) * (-2 * xi * beta) / ((1 - beta^2)^2 + (2 * xi * beta)^2);\n  G2 = (p0 / k) * (1      - beta^2) / ((1 - beta^2)^2 + (2 * xi * beta)^2);\n  Ac = u0 - G1;\n  B = (xi * omegaN * Ac - omegaBar * G2) / (omegaD);\n  myAnalyticFunc = @(t) ...\n      (Ac * cos(omegaD   * t) + B  * sin(omegaD   * t)) .* exp(-xi * omegaN * t) + ...\n      G1  * cos(omegaBar * t) + G2 * sin(omegaBar * t);\nend","category":"section"},{"location":"examples/springMass/#Numerical-solutions","page":"Spring-mass system","title":"Numerical solutions","text":"The analytic solution is used to validate two numerical solution approaches using different structural physical models, governed by the same ODE.","category":"section"},{"location":"examples/springMass/#Numerical-case-1:-truss-element-model-with-Newmark-method-and-lumped-masses","page":"Spring-mass system","title":"Numerical case 1: truss element model with Newmark method and lumped masses","text":"In this case, a truss element is considered, as shown in the figure, with Young modulus, cross-section, area, mass, nodal damping and length corresponding to the parameters considered for the spring-mass-damper system\n\n<img src=\"../../assets/springMassTrussModel.svg\" alt=\"spring-mass diagram\" width=\"800\"/>\n\nThe scalar parameters for the equivalent truss model are:\n\nl   = 10;\nA   = 0.2;\nrho = m * 2 / (A * l);\nE   = k * l /   A;\n\nwhere the material of the truss was selected to set a mass m at the node 2.\n\nassert(u0 < l, 'this analytical solution is not valid for this u0 and l0');","category":"section"},{"location":"examples/springMass/#Materials","page":"Spring-mass system","title":"Materials","text":"materials                    = struct();\nmaterials(1).modelName  = 'elastic-rotEngStr';\nmaterials(1).modelParams = [E 0];\nmaterials(1).density         = rho;","category":"section"},{"location":"examples/springMass/#Elements","page":"Spring-mass system","title":"Elements","text":"In this case only 'node' and  'truss' elements are considered and the lumped inertial formulation is set for the truss element:\n\nelements             = struct();\nelements(1).elemType = 'node';\nelements(2).elemType = 'truss';\nelements(2).elemCrossSecParams = {'circle', [sqrt(4 * A / pi)] };\nelements(2).massMatType = 'lumped';","category":"section"},{"location":"examples/springMass/#Boundary-conditions","page":"Spring-mass system","title":"Boundary conditions","text":"The node 1 is fixed, so the boundary condition set is:\n\nboundaryConds                  = struct();\nboundaryConds(1).imposDispDofs =  [1 3 5];\nboundaryConds(1).imposDispVals =  [0 0 0];\n\nThe node 2 allows the truss to move in x so the boundary condition set is:\n\nboundaryConds(2).imposDispDofs =  [3 5];\nboundaryConds(2).imposDispVals =  [0 0];\n\nant the external load is added into the same boundary condition using:\n\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) p0 * sin(omegaBar * t);\nboundaryConds(2).loadsBaseVals = [1 0 0 0 0 0];","category":"section"},{"location":"examples/springMass/#Initial-conditions","page":"Spring-mass system","title":"Initial conditions","text":"Initial displacement and velocity are set:\n\naux = zeros(6 * 2, 1);\naux(7) = u0;\ninitialConds.U = aux;\naux(7) = du0;\ninitialConds.Udot = aux;","category":"section"},{"location":"examples/springMass/#Analysis-settings","page":"Spring-mass system","title":"Analysis settings","text":"The following parameters correspond to the iterative trapezoidal Newmark method with the following tolerances, time step, tolerances and final time\n\nanalysisSettings               = struct();\nanalysisSettings.methodName    = 'newmark';\nanalysisSettings.deltaT        =   0.005;\nanalysisSettings.finalTime     =   2.5 * TN;\nanalysisSettings.stopTolDeltau =   1e-10;\nanalysisSettings.stopTolForces =   1e-10;\nanalysisSettings.stopTolIts    =   10;","category":"section"},{"location":"examples/springMass/#OtherParams","page":"Spring-mass system","title":"OtherParams","text":"The nodalDispDamping is added into the model using:\n\notherParams                  = struct();\notherParams.nodalDispDamping = c;\n\nThe name of the problem is:\n\notherParams.problemName = 'springMass_case1';","category":"section"},{"location":"examples/springMass/#mesh","page":"Spring-mass system","title":"mesh","text":"Only two nodes are considered so the nodes matrix is:\n\nmesh             = struct();\nmesh.nodesCoords = [0  0  0; ...\n                    l  0  0];\nmesh.conecCell = { };\nmesh.conecCell{ 1, 1 } = [0 1 1    1];\nmesh.conecCell{ 2, 1 } = [0 1 2    2];\nmesh.conecCell{ 3, 1 } = [1 2 0    1 2];\n\nExecute ONSAS and save the results:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUsNewmark, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/springMass/#Numerical-case-2:-truss-model-with-nodal-masses,-using-\\alpha-HHT-method-and-user-loads-function","page":"Spring-mass system","title":"Numerical case 2: truss model with nodal masses, using alpha-HHT method and user loads function","text":"","category":"section"},{"location":"examples/springMass/#Material","page":"Spring-mass system","title":"Material","text":"The nodalMass field allows to add lumped matrices to a node, since this field is used, then the equivalent rho of the material(1) aforementioned now is set to 0. Although an equal mass m is considered for u_x u_y and u_z at the node 2, so:\n\nmaterials(1).density   = 0;\nmaterials(2).nodalMass = [m m m];","category":"section"},{"location":"examples/springMass/#Boundary-conditions-2","page":"Spring-mass system","title":"Boundary conditions","text":"the boundary conditions struct is entirely re-written.\n\nboundaryConds                  = { };\nboundaryConds(1).imposDispDofs =  [1 3 5];\nboundaryConds(1).imposDispVals =  [0 0 0];\nboundaryConds(2).imposDispDofs =  [3 5];\nboundaryConds(2).imposDispVals =  [0 0];\n\nant the external load is added into the same boundary condition using:\n\nboundaryConds(3).userLoadsFilename = 'myLoadSpringMass';\n\nwhere inside the function 'myLoadSpringMass' the external force vector of the structure with 12 = (2x6) entries is computed.\n\nnow the initial condition is added to the node 2 with the second material:\n\nmesh.conecCell{ 2, 1 } = [2 1 2   2];\n\nThe alpha_HHT method with alpha=0 is equivalent to Newmark, this is employed to validate results of both methods, then:\n\nanalysisSettings.methodName = 'alphaHHT';\nanalysisSettings.alphaHHT   =   0;\n\notherParams.problemName = 'springMass_case2';\n\nExecute ONSAS and save the results:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUsHHT, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/springMass/#Numerical-case-3:-beam-element-model","page":"Spring-mass system","title":"Numerical case 3: beam element model","text":"d = l / 10;\nA   = pi * d^2 /  4;\nIzz = pi * d^4 / 64;\nE   = k * l^3 / (3 * Izz); % delta = P L3/(3EI)  =>  k = P/delta = 3EI/L3  => E = kL3/(3I)\nrho = 2 * m / (A * l);\n\nmaterials(1).modelParams = [E 0];\nmaterials(1).density  = rho;\nmaterials(1).modelName  = 'elastic-linear'; % elastic-rotEngStr should work as well\n\nelements             = {};\nelements(1).elemType = 'node';\nelements(2).elemType = 'frame'; % and not truss\nelements(2).massMatType = 'lumped';\nelements(2).elemCrossSecParams{1, 1} = 'circle';\nelements(2).elemCrossSecParams{2, 1} = [d];\nelements(2).elemTypeParams = 0;\n\nboundaryConds = {};\nboundaryConds(1).imposDispDofs =  [1 2 3 4 5 6];\nboundaryConds(1).imposDispVals =  [0 0 0 0 0 0];\n\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) p0 * sin(omegaBar * t);\nboundaryConds(2).loadsBaseVals = [0 0 1 0 0 0]; % along Y axis\n\nmesh.nodesCoords = [0  0  0; ...\n                    l  0  0];\nmesh.conecCell = { };\nmesh.conecCell{ 1, 1 } = [0 1 1    1];\nmesh.conecCell{ 2, 1 } = [0 1 2    2];\nmesh.conecCell{ 3, 1 } = [1 2 0    1 2];\n\nAn initial displacements u_0 is set in y direction:\n\naux = zeros(6 * 2, 1);\naux(6 + 3) = u0;\ninitialConds.U = aux;\naux(6 + 3) = du0;\ninitialConds.Udot = aux;\n\notherParams.problemName = 'springMass_case3';\n\nanalysisSettings.methodName    = 'newmark';\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUsBending, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\nvalsBending = matUsBending(6 + 3, :);","category":"section"},{"location":"examples/springMass/#Verification","page":"Spring-mass system","title":"Verification","text":"The numerical displacements of the node 2 is extracted for both study cases:\n\nvalsNewmark = matUsNewmark(6 + 1, :);\nvalsHHT     = matUsHHT(6 + 1, :);\n\nThe analytical solution is evaluated:\n\ntimes       = linspace(0, analysisSettings.finalTime, size(matUsHHT, 2));\nvalsAnaly   = myAnalyticFunc(times);\n\nThe boolean to validate the implementation is evaluated such as:\n\nanalyticCheckTolerance = 5e-2;\nverifBooleanNewmark =  ((norm(valsAnaly  - valsNewmark) / norm(valsAnaly)) <  analyticCheckTolerance);\nverifBooleanHHT     =  ((norm(valsAnaly  - valsHHT) / norm(valsAnaly)) <  analyticCheckTolerance);\nverifBooleanBending =  ((norm(valsBending - valsHHT) / norm(valsAnaly)) <  analyticCheckTolerance);\nverifBoolean        = verifBooleanHHT && verifBooleanNewmark && verifBooleanBending;","category":"section"},{"location":"examples/springMass/#Plot-verification","page":"Spring-mass system","title":"Plot verification","text":"The control displacement u(t) is plotted:\n\nfigure;\nhold on;\ngrid on;\nspanPlot = 8;\nlw = 2.0;\nms = 11;\nplotfontsize = 20;\nplot(times, valsAnaly, 'b-', 'linewidth', lw, 'markersize', ms);\nplot(times(1:spanPlot:end), valsNewmark(1:spanPlot:end), 'ro', 'linewidth', lw, 'markersize', ms);\nplot(times(1:spanPlot:end), valsHHT(1:spanPlot:end), 'gs', 'linewidth', lw, 'markersize', ms);\nplot(times(1:spanPlot:end), valsBending(1:spanPlot:end), 'yx', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('t [s]');\nlaby = ylabel('u(t) [m]');\nlegend('analytic', 'truss-Newmark', 'nodalMass-HHT', 'Beam-model', 'location', 'northeast');\ntitle(sprintf('dt = %.3d, m = %d, c = %d, k = %d, p0 = %d', analysisSettings.deltaT, m, c, k, p0));\nset(gca, 'linewidth', 1.0, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/springMassCheckU.png', '-dpng');\n\n<img src=\"../../assets/generated/springMassCheckU.png\" alt=\"plot check\" width=\"500\"/>","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Running-ONSAS","page":"Installation","title":"Running ONSAS","text":"The user should follow these steps to install and run ONSAS:\n\nDownload and install GNU-Octave or Matlab.\nDownload the zip file of the latest ONSAS release from this site.\nOpen GNU-Octave/Matlab and run one of the example scripts from the examples folder.","category":"section"},{"location":"install/#Visualizing-results","page":"Installation","title":"Visualizing results","text":"You can process the outputs using Octave, however, the open-source software ParaView can be used to visualize the results produced by ONSAS (in vtk format).","category":"section"},{"location":"install/#Generation-of-geometries/meshes","page":"Installation","title":"Generation of geometries/meshes","text":"The user can provide the geometry of the structure using GMSH's .msh format. GMSH is an open-source tool that allows to generate high-quality meshes.","category":"section"},{"location":"install/#Contributing","page":"Installation","title":"Contributing","text":"If you want to contribute you should create a fork and create a Pull Request in github.","category":"section"},{"location":"install/#Development-tools","page":"Installation","title":"Development tools","text":"If you want to contribute any code it is recommended that you install miss-hit, to check the styling of the code before pushing. It is recommended but not mandatory to install poetry.\n\nDoing this in linux's bash (see other OSs): \n\ncd ONSAS/utils\npython -m venv .venv\nsource .venv/bin/activate\n\nThen install poetry, install miss-hit and check\n\npip install poetry\nmake install\nmake format_check","category":"section"},{"location":"examples/cantileverBeam/#Uniform-curvature-cantilever-beam-example","page":"Cantilever Beam","title":"Uniform curvature cantilever beam example","text":"\n\nIn this tutorial, the Uniform curvature cantilever example and its resolution using ONSAS are described. The aim of this example is to validate the static co-rotational 3D beam implementation by comparing the results provided by ONSAS with the analytical solution.  The Octave script of this example is available at this url.\n\nThe problem consists in a beam, with one free end (right) submitted to a nodal moment M, and the other end (left) constrained (welded), as it is shown in the figure.\n\n<img src=\"../../assets/cantileverBeam_HTML.svg\" alt=\"structure diagram\" width=\"500\"/>\n\nBefore defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined.\n\nclose all;\n  clear all;\naddpath(genpath([pwd '/../../src']));\nE = 200e9; % Young modulus\nnu = 0.0; % Poisson\nl = 10; % length\nty = 1.0; % width\ntz = .1; % thickness\nIy = ty * tz^3 / 12;\nMobj = E * Iy * 2 * pi / l;\nnumElements = 10;","category":"section"},{"location":"examples/cantileverBeam/#Analytic-solution","page":"Cantilever Beam","title":"Analytic solution","text":"The rotation of the right end, for a given moment M, can be computed as:\n\nM( theta ) = E I_y frac theta l   ","category":"section"},{"location":"examples/cantileverBeam/#Numerical-solution","page":"Cantilever Beam","title":"Numerical solution","text":"","category":"section"},{"location":"examples/cantileverBeam/#MEB-parameters","page":"Cantilever Beam","title":"MEB parameters","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions (MEB) parameters.","category":"section"},{"location":"examples/cantileverBeam/#materials","page":"Cantilever Beam","title":"materials","text":"Since the example contains only one rod the fields of the materials struct will have only one entry. Although, it is considered constitutive behavior according to the SaintVenantKirchhoff law:\n\nmaterialsNL                 = struct();\nmaterialsNL.modelName  = 'elastic-rotEngStr';\nmaterialsNL.modelParams = [E nu];\n\nThe density is not defined, therefore it is considered as zero (default), then no inertial effects are considered (static analysis).","category":"section"},{"location":"examples/cantileverBeam/#elements","page":"Cantilever Beam","title":"elements","text":"Two different types of elements are considered, node and beam. The nodes will be assigned in the first entry (index 1) and the beam at the index 2. The elemType field is then:\n\nelements             = struct();\nelements(1).elemType = 'node';\nelements(2).elemType = 'frame';\n\nfor the geometries, the node has not geometry to assign (empty array), and the truss elements will be set as a rectangular-cross section with t_y and t_z cross-section dimensions in y and z directions, then the elemCrossSecParams field is:\n\nelements(2).elemCrossSecParams{1, 1} = 'rectangle';\nelements(2).elemCrossSecParams{2, 1} = [ty tz];","category":"section"},{"location":"examples/cantileverBeam/#boundaryConds","page":"Cantilever Beam","title":"boundaryConds","text":"The elements are submitted to two different BC settings. The first BC corresponds to a welded condition (all 6 dofs set to zero)\n\nboundaryConds                  = struct();\nboundaryConds(1).imposDispDofs = [1 2 3 4 5 6];\nboundaryConds(1).imposDispVals = [0 0 0 0 0 0];\n\nand the second corresponds to an incremental nodal moment, where the target load produces a circular form of the deformed beam.\n\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) Mobj * t;\nboundaryConds(2).loadsBaseVals = [0 0 0 -1 0 0];","category":"section"},{"location":"examples/cantileverBeam/#initial-Conditions","page":"Cantilever Beam","title":"initial Conditions","text":"homogeneous initial conditions are considered, then an empty cell is set:\n\ninitialConds = {};","category":"section"},{"location":"examples/cantileverBeam/#mesh-parameters","page":"Cantilever Beam","title":"mesh parameters","text":"The coordinates of the nodes of the mesh are given by the matrix:\n\nmesh             = struct();\nmesh.nodesCoords = [(0:(numElements))' * l / numElements  zeros(numElements + 1, 2)];\n\nThe connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEB parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:\n\nmesh.conecCell = { };\n\nthen the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. Finally the node is included.\n\nmesh.conecCell{ 1, 1 } = [0 1 1   1];\n\nthe following case only differs in the boundary condition and the node number\n\nmesh.conecCell{ 2, 1 } = [0 1 2   numElements + 1];\n\nthe beam elements are formed by the first material, the second type of element, and no boundary conditions are applied to any element.\n\nfor i = 1:numElements\n  mesh.conecCell{ i + 2, 1 } = [1 2 0  i i + 1];\nend","category":"section"},{"location":"examples/cantileverBeam/#analysisSettings","page":"Cantilever Beam","title":"analysisSettings","text":"analysisSettings               = struct();\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.deltaT        =   0.1;\nanalysisSettings.finalTime     =   1;\nanalysisSettings.stopTolDeltau =   1e-6;\nanalysisSettings.stopTolForces =   1e-6;\nanalysisSettings.stopTolIts    =   10;","category":"section"},{"location":"examples/cantileverBeam/#otherParams","page":"Cantilever Beam","title":"otherParams","text":"otherParams             = struct();\notherParams.problemName = 'uniformCurvatureCantilever-frame';\notherParams.controlDofs = [numElements + 1  4];\notherParams.plots_format = 'vtk';","category":"section"},{"location":"examples/cantileverBeam/#Analysis-case-1:-NR-with-Rotated-Eng-Strain","page":"Cantilever Beam","title":"Analysis case 1: NR with Rotated Eng Strain","text":"In the first case ONSAS is run and the solution at the dof (angle of node B) of interest is stored:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materialsNL, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nthe control dof to verificate the solution is the node angle B, this corresponds to the following dof number:\n\nangleControlDof      = (numElements + 1) * 6 - 2;\ncontrolDispsNREngRot =  -matUs(angleControlDof, :);\nloadFactorsNREngRot  =  loadFactorsMat(:, 2);\nelements             = struct();\nelements(1).elemType = 'edge';\nelements(1).elemCrossSecParams = tz;\nelements(2).elemType = 'triangle-shell';\nelements(2).elemCrossSecParams = {'thickness', tz };\nboundaryConds                  = struct();\nboundaryConds(1).imposDispDofs =  [1 2 3 4 5 6];\nboundaryConds(1).imposDispVals =  [0 0 0 0 0 0];\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) Mobj * t / (ty * tz);\nboundaryConds(2).loadsBaseVals = [0 0 0 -1 0 0];\nmesh = struct();\nbase_dir = '';\nif strcmp(getenv('TESTS_RUN'), 'yes') && isfolder('examples')\n  base_dir = ['.' filesep 'examples' filesep  'uniformCurvatureCantilever' filesep];\nend\n[mesh.nodesCoords, mesh.conecCell] = meshFileReader([base_dir 'geometry_cantilever.msh']);\nassert(max(mesh.nodesCoords(:, 1)) == l && max(mesh.nodesCoords(:, 2)) == ty);\notherParams.problemName = 'uniformCurvatureCantilever-nonLinearShell';\nanalysisSettings               = struct();\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.deltaT        =   0.05; % 100 steps\nanalysisSettings.finalTime     =   1;\nanalysisSettings.stopTolDeltau =   1e-5;\nanalysisSettings.stopTolForces =   1e-5;\nanalysisSettings.stopTolIts    =   15;\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materialsNL, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\nnode = 18;\nux_dof_shell    = node * 6 - 5;\nuz_dof_shell    = node * 6 - 1;\nangle_dof_shell = node * 6 - 2;\ncontrolDispsShellNonLinear  = -matUs(angle_dof_shell, :);\ncontrol_ux_shell            = matUs(ux_dof_shell, :);\ncontrol_uz_shell            = matUs(uz_dof_shell, :);\nloadFactorsShell            = loadFactorsMat(:, 2) * ty * tz;\n\nvec = (1e-6:0.01:2 * pi);\n\nand the analytical value of the load factors is computed\n\nanalyticLoadFactorsNREngRot = @(w) E * Iy * w / l;\nux_ana = @(t) l - l ./ (t / 2) .* sin(t / 2) .* cos(t / 2);\nuz_ana = @(t) l ./ (t / 2) .* (sin(t / 2)).^2;","category":"section"},{"location":"examples/cantileverBeam/#Verification","page":"Cantilever Beam","title":"Verification","text":"verifBoolean = norm(analyticLoadFactorsNREngRot(controlDispsNREngRot) - ...\n                    loadFactorsNREngRot')  < ...\n              (norm(analyticLoadFactorsNREngRot(controlDispsNREngRot)) * 1e-4) && ...\n              norm(analyticLoadFactorsNREngRot(controlDispsShellNonLinear) - ...\n                   loadFactorsShell')  < ...\n              (norm(analyticLoadFactorsNREngRot(controlDispsShellNonLinear)) * 1e-2);\nlw = 2.0;\nms = 5;\nplotfontsize = 10;\nfigure;\nplot(ux_ana(vec), analyticLoadFactorsNREngRot(vec), 'b-', 'linewidth', lw, 'markersize', ms);\nhold on;\ngrid on;\nplot(uz_ana(vec), analyticLoadFactorsNREngRot(vec), 'k-', 'linewidth', lw, 'markersize', ms);\nplot(-control_ux_shell(1:2:end), loadFactorsShell(1:2:end), 'g--*', 'linewidth', lw, 'markersize', ms);\nplot(control_uz_shell(1:2:end), loadFactorsShell(1:2:end), 'r--x', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('Displacement');\nlaby = ylabel('\\lambda');\nlegend('analytic_ux', 'analytic_uz', 'NL_ux', 'NL_uz', 'location', 'East');\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/verifCantileverBeam.png', '-dpng');\n\n<img src=\"../../assets/verifCantileverBeam.png\" alt=\"plot check\" width=\"500\"/>","category":"section"},{"location":"examples/simplePropeller/#Simple-Propeller-example","page":"Propeller model","title":"Simple Propeller example","text":"In this example a simple propeller problem, inspired in an example this article, is considered. Before definit variable, the workspace is cleared and the src folder is added to the path\n\nclose all;\n  clear all;\naddpath(genpath([pwd '/../../src']));","category":"section"},{"location":"examples/simplePropeller/#Problem-definition","page":"Propeller model","title":"Problem definition","text":"The propeller has three blades with circular cross section and a uniform constant fluid flow is assumed as shown in the figure. Only lift is considered.\n\n<img src=\"../../assets/diagprop.png\" alt=\"plot check\" width=\"600\"/>\n\nThe wind velocity is assumed constant and uniform, given by the function windVel.m with one argument (time), located in the same folder. Then the fluid velocity is computed as:\n\nva = feval('windVel', 0, 0);\n\nThe density and kinematic viscosity are set:\n\nrhoA = 1.225;\nnuA = 1.6e-5;\n\nThe blades are considered to have only lift, with a lift coefficient given by the function liftCoef.m placed in the same folder.\n\nc_l = feval('liftCoef', 0);\n\nThe material parameters of the blades correspond to steel with Young modulus, Poisson coefficient and density given by:\n\nE = 210e9;\nnu = 0.3;\nrho = 6000;\n\nand the geometric parameters of the blades for length and diameter are set as:\n\nl = 3;\nd = 0.1;","category":"section"},{"location":"examples/simplePropeller/#Analytical-solution","page":"Propeller model","title":"Analytical solution","text":"Since only lift is considered, an analytical solution can be computed. The the lift load per unit of length is obtained as:\n\nfl = 1 / 2 * c_l * rhoA * norm(va)^2 * d;\n\nthe total moment M_x in node 1 is given by the sum of the moments for the three blades:\n\nmoment1x = 3 * fl * l * l / 2;\n\nand then the angular moment is:\n\nbladeMass = rho * l * pi * d^2 / 4;\nJrho =  3 * 1 / 3 * bladeMass  * l^2;\n\nThen, integrating, the angle theta_x can be obtained as a function of time.\n\nangleXnode1 = @(t)  moment1x / Jrho / 2 * t.^2;\n\nIf the blades are considered stiff enough and only lift is considered, this rigid-rotation solution can be used to verify the numerical solution.","category":"section"},{"location":"examples/simplePropeller/#Numerical-solution","page":"Propeller model","title":"Numerical solution","text":"Set the material parameters:\n\nmaterials             = struct();\nmaterials.modelName   = 'elastic-rotEngStr';\nmaterials.modelParams = [E nu];\nmaterials.density     = rho;","category":"section"},{"location":"examples/simplePropeller/#elements","page":"Propeller model","title":"elements","text":"The elements are given by: nodes\n\nelements             = struct();\nelements(1).elemType = 'node';\n\nframe elements for modelling the blades\n\nelements(2).elemType = 'frame';\nelements(2).elemCrossSecParams = {'circle'; d };\nelements(2).massMatType =  'consistent';\n\nwith the definition of the aerodynamic forces\n\nelements(2).aeroCoefFunctions = {@(beta, Re) 0, 'liftCoef', @(beta, Re) 0};\n\nand a auxiliar truss element for the pole\n\nelements(3).elemType = 'truss';\nelements(3).elemCrossSecParams = {'circle'; 1.5 * d };\nelements(3).massMatType =  'lumped';","category":"section"},{"location":"examples/simplePropeller/#boundary-Conditions","page":"Propeller model","title":"boundary Conditions","text":"The only boundary condition is the one of the center node, with all the dofs fixed except for the rotation theta_x\n\nboundaryConditions             = struct();\nboundaryConds(1).imposDispDofs = [1 3 4 5 6];\nboundaryConds(1).imposDispVals = [0 0 0 0 0];","category":"section"},{"location":"examples/simplePropeller/#mesh","page":"Propeller model","title":"mesh","text":"The mesh is defined\n\nmesh             = struct();\nmesh.nodesCoords = [0         0                     0; ...\n                    0         l * sin(pi)           l * cos(pi); ...\n                    0         l * sin(pi / 3)       l * cos(pi / 3); ...\n                    0         l * sin(4 * pi / 3)   -l * cos(4 * pi / 3); ...\n                    -d * .75  0                     d; ...\n                    -d * .75  0                     -l * 1.5];\n\nAnd a simple connectivity is required since only one frame element is used for each blade\n\nmesh.conecCell         = { };\nmesh.conecCell{ 1, 1 } = [0 1 1   1];\nmesh.conecCell{ 2, 1 } = [1 2 0   1 2];\nmesh.conecCell{ 3, 1 } = [1 2 0   1 3];\nmesh.conecCell{ 4, 1 } = [1 2 0   1 4];\n\nThese are auxiliar elements (nodes and truss) used to model the pole\n\nmesh.conecCell{ 5, 1 } = [0 1 1   5];\nmesh.conecCell{ 6, 1 } = [0 1 1   6];\nmesh.conecCell{ 7, 1 } = [1 3 0   5 6];","category":"section"},{"location":"examples/simplePropeller/#initial-Conditions","page":"Propeller model","title":"initial Conditions","text":"homogeneous initial conditions are considered, then an empty struct is set:\n\ninitialConds = struct();","category":"section"},{"location":"examples/simplePropeller/#analysisSettings","page":"Propeller model","title":"analysisSettings","text":"The analysis settings are set\n\nanalysisSettings                        = struct();\nanalysisSettings.finalTime              =   400;\nanalysisSettings.deltaT                 =   5;\nanalysisSettings.methodName             = 'alphaHHT';\nanalysisSettings.stopTolIts             =   50;\nanalysisSettings.geometricNonLinearAero = true;\nanalysisSettings.stopTolDeltau          =   0;\nanalysisSettings.stopTolForces          =   1e-5;\nanalysisSettings.fluidProps = { rhoA; nuA; 'windVel' };","category":"section"},{"location":"examples/simplePropeller/#otherParams","page":"Propeller model","title":"otherParams","text":"otherParams = struct();\notherParams.problemName =  'simplePropeller';\notherParams.plots_format = 'vtk';","category":"section"},{"location":"examples/simplePropeller/#Run-ONSAS","page":"Propeller model","title":"Run ONSAS","text":"[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/simplePropeller/#Verification","page":"Propeller model","title":"Verification","text":"numerical time vector is given by:\n\ntimeVec = linspace(0, analysisSettings.finalTime, size(matUs, 2));\n\nnumerical rotation is obtained from the ONSAS matUs:\n\ndofAngleXnode1 = 2;\nangleXnode1Numeric = -matUs(dofAngleXnode1, :);\n\nThe analytic rotation is:\n\nangleXnode1Analytic = angleXnode1(timeVec);\n\nand the norm of the difference is computed and the test is verified\n\nverifBoolean = norm(angleXnode1Numeric - angleXnode1Analytic) < (norm(angleXnode1Analytic) * 5e-2);","category":"section"},{"location":"examples/simplePropeller/#Plots","page":"Propeller model","title":"Plots","text":"lw = 2.0;\nms = 10;\nplotfontsize = 22;\nspanPlotTime = 2;\nfig1 = figure;\nplot(timeVec(1:spanPlotTime:end), angleXnode1Analytic(1:spanPlotTime:end), 'b-x', 'linewidth', lw, 'markersize', ms);\nhold on;\ngrid on;\nplot(timeVec(1:spanPlotTime:end), angleXnode1Numeric(1:spanPlotTime:end), 'ko', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('time(s)');\nlaby = ylabel('\\theta_x node 1');\nlegend('analytic', 'numeric', 'location', 'North');\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\ntitle('simple propeller test');\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  print(fig1, 'output/verifPropeller.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\n<img src=\"../../assets/generated/verifPropeller.png\" alt=\"plot check\" width=\"500\"/>\n\nThe obtained simulation is:\n\n<img src=\"https://github.com/ONSAS/ONSAS/blob/master/docs/src/assets/propeller.gif?raw=true\" alt=\"propeller animation\">","category":"section"},{"location":"examples/staticVonMisesTruss/#Static-Von-Mises-Truss-example","page":"Static Von-Mises Truss","title":"Static Von-Mises Truss example","text":"(Image: Octave script)\n\nIn this example the Static Von Mises Truss problem and its resolution using ONSAS are described. The aim of this example is to verify the implementations of the Newton-Raphson and Newton-Raphson-Arc-Length methods by comparing the results provided with the analytic solutions.\n\nThe structural model is formed by two truss elements with length L as it is shown in the figure, with nodes 1 and 3 fixed, and node 2 submitted to a nodal load P and constrained to move only in the x-z plane.\n\n<img src=\"../../assets/vonMisesTruss.svg\" alt=\"von-mises truss structure diagram\" width=\"500\"/>","category":"section"},{"location":"examples/staticVonMisesTruss/#Analytic-solutions","page":"Static Von-Mises Truss","title":"Analytic solutions","text":"The solutions for the nonlinear cases are developed in section 2.3 of (Bazzano and Pérez Zerpa, 2017). The expressions obtained for different strain measures are:\n\nRotated-Engineering: P = dfracEA_o(z_2+w)left(sqrt(w+z_2)^2+x_2^2-l_oright)l_osqrt(w+z_2)^2+x_2^2\nSVK: P = dfracEA_o (z_2+w)left( 2 z_2 w + w^2 right)  2 l_o^3 \n\nwhere x_2 and z_2 are the coordinates of node 2 in the reference configuration and w is the vertical displacement in the z direction.","category":"section"},{"location":"examples/staticVonMisesTruss/#Numerical-solutions","page":"Static Von-Mises Truss","title":"Numerical solutions","text":"Before defining the structs, the workspace is cleared, the ONSAS directory is added to the path\n\nclose all;\n  clear all;\naddpath(genpath([pwd '/../../src']));\n\nFirst some scalar parameters are defined and computed\n\nE = 210e9;\nnu = 0;\nA = 2.5e-3;\nang1 = 65;\nL = 2;\nx2 = cos(ang1 * pi / 180) * L;\nz2 = sin(ang1 * pi / 180) * L;","category":"section"},{"location":"examples/staticVonMisesTruss/#MEB-parameters","page":"Static Von-Mises Truss","title":"MEB parameters","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions (MEB) parameters.","category":"section"},{"location":"examples/staticVonMisesTruss/#materials","page":"Static Von-Mises Truss","title":"materials","text":"The materials struct is initialized as empty.\n\nmaterials                 = struct();\n\nSince for each model both bars are formed by the same material only one materials struct is defined. The constitutive behavior considered in the first analysis case is an elastic behavior for the Rotated Engineering strain, then:\n\nmaterials.modelName  = 'elastic-rotEngStr';\n\nand in the field modelParams a vector with the parameters of the Engineering Strain model is set\n\nmaterials.modelParams = [E nu];\n\nwhich in the case of this material model are the Young modulus and the Poisson ratio. The field density is not set, then the default rho = 0 value is considered by ONSAS.","category":"section"},{"location":"examples/staticVonMisesTruss/#elements","page":"Static Von-Mises Truss","title":"elements","text":"The elements struct is initialized as empty\n\nelements             = struct();\n\nTwo different types of elements are required to create the model: node and truss, thus, the elements struct will have two entries. The type of the first entry is\n\nelements(1).elemType = 'node';\n\nand the second entry is\n\nelements(2).elemType = 'truss';\n\nfor the geometries, the node has no geometry to assign, and the truss elements will be set as the native circle cross-section, then the elemCrossSecParams field is:\n\nelements(2).elemCrossSecParams = { 'circle', sqrt(A * 4 / pi) };","category":"section"},{"location":"examples/staticVonMisesTruss/#boundaryConds","page":"Static Von-Mises Truss","title":"boundaryConds","text":"The elements are submitted to two different BoundaryConditions, then the struct boundaryConds will have length two. The nodes 1 and 3 are fixed, without loads applied (this is the first BC), and node 2 has a constraint in displacement and an applied load (second BC). For the displacements, the first BC corresponds to a xyz-fixed displacement,\n\nboundaryConds                  = struct();\nboundaryConds(1).imposDispDofs = [1 3 5];\nboundaryConds(1).imposDispVals = [0 0 0];\n\nand the second BC corresponds to a zero displacement only in the y direction.\n\nboundaryConds(2).imposDispDofs =  3;\nboundaryConds(2).imposDispVals =  0;\n\nRegarding the loads, the second BC is set so that the final load factor is 3 cdot 10^8 at 1 second. The default zero density is used, then no inertial effects are considered.\n\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) 3.0e8 * t;\nboundaryConds(2).loadsBaseVals = [0 0 0 0 -1 0];","category":"section"},{"location":"examples/staticVonMisesTruss/#mesh-parameters","page":"Static Von-Mises Truss","title":"mesh parameters","text":"The coordinates of the nodes of the mesh are given by the matrix:\n\nmesh             = struct();\nmesh.nodesCoords = [0  0   0; ...\n                    x2  0  z2; ...\n                    2 * x2  0   0];\n\nwhere the columns 1,2 and 3 correspond to x, y and z coordinates, respectively, and the row i-th corresponds to the coordinates of node i.\n\nThe connectivity is introduced using the conecCell cell. Each entry of the cell (indexed using {}) contains a vector with the four indexes of the MEB parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:\n\nmesh.conecCell = cell(5, 1);\n\nThen the entry of node 1 is introduced:\n\nmesh.conecCell{ 1, 1 } = [0 1 1   1];\n\nthe first MEB parameter (Material) is set as zero (since nodes dont have material). The second parameter corresponds to the Element, and a 1 is set since node is the first entry of the  elements.elemType cell. For the BC index, we consider that node 1 is fixed, then the first index of the boundaryConds struct is used. Finally, at the end of the vector the number of the node is included (1). A similar approach is used for node 3,\n\nmesh.conecCell{ 2, 1 } = [0 1 1  3];\n\nand for node 2 only the boundary condition is changed.\n\nmesh.conecCell{ 3, 1 } = [0 1 2  2];\n\nRegarding the truss elements, the first material is considered, the second type of element, and no boundary conditions are applied.\n\nmesh.conecCell{ 4, 1 } = [1 2 0   1 2];\nmesh.conecCell{ 5, 1 } = [1 2 0   2 3];","category":"section"},{"location":"examples/staticVonMisesTruss/#initial-Conditions","page":"Static Von-Mises Truss","title":"initial Conditions","text":"homogeneous initial conditions are considered, then an empty cell is set:\n\ninitialConds = struct();","category":"section"},{"location":"examples/staticVonMisesTruss/#analysisSettings","page":"Static Von-Mises Truss","title":"analysisSettings","text":"The method used in the analysis is the Newton-Raphson, then the field methodName must be introduced as:\n\nanalysisSettings               = {};\nanalysisSettings.methodName    = 'newtonRaphson';\n\nand the following parameters correspond to the iterative numerical analysis settings\n\nanalysisSettings.deltaT        =   0.1;\nanalysisSettings.finalTime     =   1;\nanalysisSettings.stopTolDeltau =   1e-9;\nanalysisSettings.stopTolForces =   1e-9;\nanalysisSettings.stopTolIts    =   15;","category":"section"},{"location":"examples/staticVonMisesTruss/#otherParams","page":"Static Von-Mises Truss","title":"otherParams","text":"otherParams              = struct();\notherParams.problemName  = 'staticVonMisesTruss_NR_RotEng';\notherParams.plots_format = 'vtk';\notherParams.plots_deltaTs_separation = 2;","category":"section"},{"location":"examples/staticVonMisesTruss/#Analysis-case-1:-Newton-Raphson-with-Rotated-Eng-Strain","page":"Static Von-Mises Truss","title":"Analysis case 1: Newton-Raphson with Rotated Eng Strain","text":"In the first case ONSAS is run and the solution at the dof of interest is stored.\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\ncontrolDispsNREngRot =  -matUs(11, :);\nloadFactorsNREngRot  =  loadFactorsMat(:, 2);","category":"section"},{"location":"examples/staticVonMisesTruss/#Analysis-case-2:-Newton-Raphson-with-linear-elastic-behavior","page":"Static Von-Mises Truss","title":"Analysis case 2: Newton-Raphson with linear elastic behavior","text":"In this case a linear elastic behavior is assumed. Then the material modelName is overwritten\n\nmaterials.modelName = 'elastic-linear';\notherParams.problemName  = 'staticVonMisesTruss_elastic-linear';\nanalysisSettings.finalTime  =   1.5;\n\nand the analysis is run again\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nthe displacements are extracted\n\ncontrolDispsNRlinearElastic =  -matUs(11, :);\nloadFactorsNRlinearElastic  =  loadFactorsMat(:, 2);\n\nand the analytic values of the load factor are computed, as well as its difference with the numerical solution\n\nanalyticLoadFactorsNREngRot = @(w) -2 * E * A * ...\n     (((z2 + (-w)).^2 + x2^2 - L^2) ./ (L * (L + sqrt((z2 + (-w)).^2 + x2^2)))) .* ...\n       (z2 + (-w))                    ./ (sqrt((z2 + (-w)).^2 + x2^2));\ndifLoadEngRot = analyticLoadFactorsNREngRot(controlDispsNREngRot)' - loadFactorsNREngRot;","category":"section"},{"location":"examples/staticVonMisesTruss/#Analysis-case-3:-NR-with-Green-Strain","page":"Static Von-Mises Truss","title":"Analysis case 3: NR with Green Strain","text":"In order to perform a SVK case analysis, the material is changed and the problemName is also updated\n\nelements(2).elemCrossSecParams = { 'generic', [A 1 1 1] };\notherParams.problemName        = 'staticVonMisesTruss_NR_Green';\nmaterials.modelName            = 'elastic-SVK';\nanalysisSettings.finalTime =   1.0;\nlambda = E * nu / ((1 + nu) * (1 - 2 * nu));\nmu = E / (2 * (1 + nu));\nmaterials.modelParams = [lambda mu];\n\nthe load history is also changed\n\nboundaryConds(2).loadsTimeFact = @(t) 1.5e8 * t;\n\nand the analysis is run\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nand the displacements are extracted\n\ncontrolDispsNRGreen =  -matUs(11, :);\nloadFactorsNRGreen  =  loadFactorsMat(:, 2);\n\nthe analytic solution is computed\n\nanalyticLoadFactorsGreen = @(w) -2 * E * A * ((z2 + (-w)) .* (2 * z2 * (-w) + w.^2)) ./ (2.0 * L^3);\ndifLoadGreen = analyticLoadFactorsGreen(controlDispsNRGreen)' - loadFactorsNRGreen;","category":"section"},{"location":"examples/staticVonMisesTruss/#Analysis-case-4:-NR-AL-with-Green-Strain","page":"Static Von-Mises Truss","title":"Analysis case 4: NR-AL with Green Strain","text":"In this case the rectangle section is considered (with the same area as the previous cases) and the Arc-Length resolution method is used.\n\notherParams.problemName       = 'staticVonMisesTruss_NRAL_Green';\n\nthe section is changed\n\nelements(2).elemCrossSecParams{1, 1} = 'rectangle';\nelements(2).elemCrossSecParams{2, 1} = [sqrt(A) sqrt(A)];\n\nthe numerical method is changed\n\nanalysisSettings.methodName   = 'arcLength';\nanalysisSettings.finalTime    = 1;\n\na varying step of displacements is considered\n\nanalysisSettings.incremArcLen = [0.15 * ones(1, 8) 0.3 * ones(1, 2)];\nanalysisSettings.iniDeltaLamb = boundaryConds(2).loadsTimeFact(.2) / 100;\nanalysisSettings.posVariableLoadBC = 2;\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that, the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nand the control numerical displacements and loadfactors are extracted\n\ncontrolDispsNRALGreen =  -matUs(11, :);\nloadFactorsNRALGreen  =  loadFactorsMat(:, 2);\n\nand compared with analytic solutions.\n\nanalyticLoadFactorsNRALGreen = analyticLoadFactorsGreen(controlDispsNRALGreen);\ndifLoadGreenNRAL = analyticLoadFactorsNRALGreen' - loadFactorsNRALGreen;","category":"section"},{"location":"examples/staticVonMisesTruss/#Analysis-case-5:-NR-AL-Jirasek-variant","page":"Static Von-Mises Truss","title":"Analysis case 5: NR-AL Jirasek variant","text":"elements(2).elemCrossSecParams = { 'rectangle', [sqrt(A) sqrt(A)] };\notherParams.problemName       = 'staticVonMisesTruss_NRAL_Jirasek_Green';\nanalysisSettings.incremArcLen = 0.15;\n\nSets arcLengthFlag = 2 to secifiy Jirasek constraint method.\n\nanalysisSettings.ALdominantDOF = [11 -1];\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\ncontrolDispsNRAL_Jirasek_Green =  -matUs(11, :);\nloadFactorsNRAL_Jirasek_Green  =  loadFactorsMat(:, 2);\nanalyticLoadFactorsNRAL_Jirasek_Green = analyticLoadFactorsGreen(controlDispsNRAL_Jirasek_Green);\ndifLoadGreenNRAL_Jirasek = analyticLoadFactorsNRAL_Jirasek_Green' - loadFactorsNRAL_Jirasek_Green;","category":"section"},{"location":"examples/staticVonMisesTruss/#Verification","page":"Static Von-Mises Truss","title":"Verification","text":"the numerical resolution is validated for both strain measures.\n\nverifBoolean =  ((norm(difLoadEngRot) / norm(loadFactorsNREngRot)) <  1e-4) && ...\n                ((norm(difLoadGreen) / norm(loadFactorsNRGreen)) <  1e-4) && ...\n                ((norm(difLoadGreenNRAL) / norm(loadFactorsNRALGreen)) <  1e-4) && ...\n                ((norm(difLoadGreenNRAL_Jirasek) / norm(loadFactorsNRAL_Jirasek_Green)) <  1e-4);","category":"section"},{"location":"examples/staticVonMisesTruss/#Plots","page":"Static Von-Mises Truss","title":"Plots","text":"Finally the solutions are plotted.\n\nlw = 2.0;\nms = 11;\nplotfontsize = 18;\nfigure;\nplot(controlDispsNREngRot, analyticLoadFactorsNREngRot(controlDispsNREngRot), 'b-x', 'linewidth', lw, 'markersize', ms);\nhold on;\ngrid on;\nplot(controlDispsNREngRot, loadFactorsNREngRot, 'k-o', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsNRALGreen, analyticLoadFactorsGreen(controlDispsNRALGreen), 'g-x', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsNRGreen, loadFactorsNRGreen, 'r-s', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsNRALGreen, loadFactorsNRALGreen, 'c-^', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsNRAL_Jirasek_Green, loadFactorsNRAL_Jirasek_Green, 'y-*', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsNRlinearElastic, loadFactorsNRlinearElastic, 'm-+', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('Displacement w(t)');\nlaby = ylabel('\\lambda(t)');\nlegend('analytic-RotEng', 'NR-RotEng', 'analytic-Green', 'NR-Green', 'NRAL-Green', 'NRAL-Jirasek-Green', 'elastic-linear', 'location', 'northoutside');\nset(gca, 'linewidth', 1.0, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/vonMisesTrussCheck.png', '-dpng');\n\n<img src=\"../../assets/generated/vonMisesTrussCheck.png\" alt=\"plot check\" width=\"500\"/>","category":"section"},{"location":"examples/dragBeamReconfiguration/#Reconfiguration-cantilever-beam-example","page":"Reconfiguration beam","title":"Reconfiguration cantilever beam example","text":"(Image: Octave script)\n\nIn this tutorial, a cantilever beam submitted to a flow producing drag forces is considered. The main goal is to validate the drag forces computation considering reconfiguration in a problem with large displacements. The example is based on one of the problems considered in this reference, where a reference solution is presented and validated with experimental data. The reference solution was generated with the code publicly available in this repository\n\nThe problem consists in a cantilever beam submitted to a fluid flow with uniform velocity v_a(x,t) = v_a(t) c_2, as shown int he Figure bellow. The beam is clamped on the boundary at x=0 m, and the span length is L. The cross-section of the beam is circular with diameter d. For the material of the beam a linear elastic isotropic model is considered, with Young modulus E density rho.\n\n<img src=\"../../assets/dragBeamReconfiguration/ilus.svg\" alt=\"general sketch\" width=\"450\"/>","category":"section"},{"location":"examples/dragBeamReconfiguration/#Dimensionless-analysis","page":"Reconfiguration beam","title":"Dimensionless analysis","text":"\n\nThe problem can be studied through the following dimensionless numbers:\n\nc_y = fracrho_f L^3 v_a^216 E I_zz qquad mathcalR = fracFfrac12rho_f L d c_d v_a^2\n\nwhere  F is the global drag force towards c_2, c_y is the Cauchy number that describes the ratio between the stiffness of the beam and the flow load and the reconfiguration number mathcalR reflects the geometric nonlinear effect by dividing the drag of the flexible beam to that of a rigid one of the same geometry","category":"section"},{"location":"examples/dragBeamReconfiguration/#Numerical-solution","page":"Reconfiguration beam","title":"Numerical solution","text":"\n\nBefore defining the structs, the workspace is cleaned and the ONSAS directory is added:\n\nclose all;\nif ~strcmp(getenv('TESTS_RUN'), 'yes')\n  clear all;\nend\naddpath(genpath([pwd '/../../src']));\n\nThe problem parameters are loaded:\n\n[L, d, Izz, E, nu, rhoS, rhoF, nuF, ~, NR, cycd_vec, uydot_vec] = loadParametersCirc();\n\nwhere rho_f and rho_s are the fluid and solid densities respectively, nu is the fluid eenematic viscosity, and  NR is the number of load steps (or velocity cases solved):\n\nThe number of elements employed to discretize the beam is:\n\nnumElements = 10;","category":"section"},{"location":"examples/dragBeamReconfiguration/#MEB-parameters","page":"Reconfiguration beam","title":"MEB parameters","text":"","category":"section"},{"location":"examples/dragBeamReconfiguration/#materials","page":"Reconfiguration beam","title":"materials","text":"Since the example contains only one material and co-rotational strain element so then materials struct is:\n\nmaterials             = struct();\nmaterials.modelName   = 'elastic-rotEngStr';\nmaterials.modelParams = [E nu];\nmaterials.density     = rhoS;","category":"section"},{"location":"examples/dragBeamReconfiguration/#elements","page":"Reconfiguration beam","title":"elements","text":"Two different types of elements are considered, node and frames. The nodes will be assigned in the first entry (index 1) and the beam at the index 2. The elemType field is then:\n\nelements(1).elemType = 'node';\nelements(2).elemType = 'frame';\n\nfor the geometries, the node has not geometry to assign (empty array), and frame elements will be set as a circular section with d diameter.\n\nelements(2).elemCrossSecParams{1, 1} = 'circle';\nelements(2).elemCrossSecParams{2, 1} = [d];\n\nwhere the aerodynamic coefficents and the chord vector are set by default for 'circle' cross sections type. For the validation case a constant drag coefficients c_d =1.2\" is used, this is defined in the 'dragCircular' function:\n\nelements(2).aeroCoefFunctions = {'dragCircular', [], []};","category":"section"},{"location":"examples/dragBeamReconfiguration/#boundaryConds","page":"Reconfiguration beam","title":"boundaryConds","text":"Only one welded (6 degrees of freedom are set to zero) boundary condition (BC) is considered:\n\nboundaryConds = struct();\nboundaryConds(1).imposDispDofs = [1 2 3 4 5 6];\nboundaryConds(1).imposDispVals = [0 0 0 0 0 0];","category":"section"},{"location":"examples/dragBeamReconfiguration/#initial-Conditions","page":"Reconfiguration beam","title":"initial Conditions","text":"Any non-homogeneous initial condition (IC) are set for this case, then an empty struct is used:\n\ninitialConds = struct();","category":"section"},{"location":"examples/dragBeamReconfiguration/#mesh-parameters","page":"Reconfiguration beam","title":"mesh parameters","text":"The coordinates of the mesh nodes are given by the matrix:\n\nmesh = struct();\nmesh.nodesCoords = [(0:(numElements))' * L / numElements  zeros(numElements + 1, 2)];\n\nThe connectivity is introduced using the conecCell. Each entry of the cell contains a vector with the four indexes of the MEB parameters, followed by the indexes of nodes that compose the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:\n\nmesh.conecCell = { };\n\nthen the first welded node is defined with material (M) zero since nodes don't have material, the first element (E) type (the first entry of the elements struct), and (B) is the first entry of the the boundaryConds struct. Finally the node is assigned:\n\nmesh.conecCell{ 1, 1 } = [0 1 1   1];\n\nNext the frame elements MEB parameters are set. The frame material is the first material of materials struct, then 1 is assigned. The second entry of the elements struct correspond to the frame element employed, so 2 is set. Finally no BC is required for this element, then 0 is used.  Consecutive nodes build the element so then the mesh.conecCell is:\n\nfor i = 1:numElements\n  mesh.conecCell{ i + 1, 1 } = [1 2 0   i i + 1];\nend","category":"section"},{"location":"examples/dragBeamReconfiguration/#analysisSettings","page":"Reconfiguration beam","title":"analysisSettings","text":"The fluid properties are set into fluidProps field into analysisSettings struct. In this field the fluid velocity, viscosity and density are defined, This will apply a external fluid loads according to the quasi-steady theory for each element with aerodynamic coefficients fields into the elements struct. The name of the fluid velocity function located on the same example path is introduced as a string 'windVelCircStatic':\n\nanalysisSettings = struct();\nanalysisSettings.fluidProps = {rhoF; nuF; 'windVelCircStatic'};\n\nThe geometrical non-linear effects and the aerodynamic stiffness matrix are considered in this case to compute the aerodynamic force vector:\n\nanalysisSettings.geometricNonLinearAero = true;\nanalysisSettings.computeAeroStiffnessMatrix = true;\n\nsince this problem is static, then a N-R method is employed. The time step deltaT is 1 since the time here is an index in the fluid velocity vector uydot_vec untile the length of this vector NR is reached:\n\nanalysisSettings.deltaT        =   1;\nanalysisSettings.finalTime     =   NR;\nanalysisSettings.methodName    = 'newtonRaphson';\n\nNext the maximum number of iterations per load(time) step, the residual force and the displacements tolerances are set to (if null tolerance is set the criterion is not considered):\n\nanalysisSettings.stopTolDeltau =   0;\nanalysisSettings.stopTolForces =   1e-8;\nanalysisSettings.stopTolIts    =   50;","category":"section"},{"location":"examples/dragBeamReconfiguration/#otherParams","page":"Reconfiguration beam","title":"otherParams","text":"The name of the problem and vtk format output are selected:\n\notherParams  = struct();\notherParams.problemName = 'staticReconfigurationCircleUserDefinedDrag';\notherParams.plots_format = 'vtk';","category":"section"},{"location":"examples/dragBeamReconfiguration/#Case-1:-validation-case-with-constant-c_d-1.2","page":"Reconfiguration beam","title":"Case 1: validation case with constant c_d = 12","text":"The ONSAS software is executed for the parameters above defined and the displacement solution of each load(time) step is saved in matUsCase1matrix:\n\nThe reaction forces at x=0 are stored  in the following vector and declaring a global variable:\n\nglobal globalReactionForces\nglobalReactionForces = zeros(6 * analysisSettings.finalTime, 1);\n\nThe node index where the reaction forces are computed is:\n\nglobal glboalNodeReactionForces\nglboalNodeReactionForces = 1;","category":"section"},{"location":"examples/dragBeamReconfiguration/#Numeric-solution","page":"Reconfiguration beam","title":"Numeric solution","text":"Execute ONSAS and save the results:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUsCase1, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/dragBeamReconfiguration/#Verification","page":"Reconfiguration beam","title":"Verification","text":"\n\nThe numerical solution is extracted. First the reference coordinaes\n\nxref = mesh.nodesCoords(:, 1);\nyref = mesh.nodesCoords(:, 2);\nzref = mesh.nodesCoords(:, 3);\n\nThen the values of R and C_y C_d are computed :\n\nnumLoadSteps = size(matUsCase1, 2);\ntimeVec = linspace(0, analysisSettings.finalTime, numLoadSteps);\nCy = zeros(numLoadSteps - 1, 1);\nR  = zeros(numLoadSteps - 1, 1);\nC_d = feval(elements(2).aeroCoefFunctions{1}, 0, 0);\nfor windVelStep = 1:numLoadSteps - 1\n  % Compute dimensionless magnitudes\n  windVel         = feval(analysisSettings.fluidProps{3, :}, 0, timeVec(windVelStep + 1));\n  normWindVel     = norm(windVel);\n  dirWindVel      = windVel / normWindVel;\n  Cy(windVelStep) =  1 / 2 * rhoF * normWindVel^2 * (L)^3 * d / (E * Izz);\n  % numeric drag\n  FReaction = globalReactionForces((windVelStep - 1) * 6 + 1:windVelStep * 6);\n  FDragi = FReaction(3);\n  FDRef  = 1 / 2 * rhoF * normWindVel^2 * C_d * d * L;\n  R(windVelStep) =  abs(FDragi) / (FDRef);\nend","category":"section"},{"location":"examples/dragBeamReconfiguration/#Gosselin-et.Al-2010-solution","page":"Reconfiguration beam","title":"Gosselin et.Al 2010 solution","text":"base_dir = '';\nif strcmp(getenv('TESTS_RUN'), 'yes') && isfolder('examples')\n  base_dir = ['.' filesep 'examples' filesep 'dragBeamReconfiguration' filesep];\nend\nload([base_dir 'Gosselin2010_data.mat'], 'def', 'resudrag');","category":"section"},{"location":"examples/dragBeamReconfiguration/#Validation-plots","page":"Reconfiguration beam","title":"Validation plots","text":"The plot parameters are:\n\nlw = 4;\nms = 8;\naxislw = 1;\naxisFontSize = 20;\nlegendFontSize = 15;\ncurveFontSize = 15;\nGline = 'k-';\nONSASline = 'bo';\nONSASlineBuiltInDrag = 'rx';\n\nThe modified Cauchy number vs R is plotted:\n\nfig1 = figure(1);\nloglog(C_d * Cy, R, ONSASline, 'linewidth', lw, 'markersize', ms);\nhold on;\nloglog(resudrag(:, 1), resudrag(:, 2), Gline, 'linewidth', lw, 'markersize', ms);\nlegend('ONSAS', 'Gosselin2010');\nlabx = xlabel(' c_y*c_d ');\nlaby = ylabel('R');\nset(legend, 'linewidth', axislw, 'fontsize', legendFontSize, 'location', 'eastOutside');\nset(gca, 'linewidth', axislw, 'fontsize', curveFontSize);\nset(labx, 'FontSize', axisFontSize);\nset(laby, 'FontSize', axisFontSize);\ngrid on;\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  figure(1);\n  print('output/RvsCyCd.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\nDeformed configurations for different cauchy numbers\n\nfig3 = figure(3);\nplot(xref, yref, 'k--', 'linewidth', lw, 'markersize', ms);\nhold on;\ngrid on;\nplot(0, 0,  ONSASline, 'linewidth', lw, 'markersize', ms);\nplot(0, 0,  ONSASlineBuiltInDrag, 'linewidth', lw, 'markersize', ms);\nfor nr = 1:analysisSettings.finalTime\n  % Numerical deformed coordinates solution\n  xdef = xref + matUsCase1(1:6:end, nr + 1);\n  ydef = yref + matUsCase1(3:6:end, nr + 1);\n  zdef = zref + matUsCase1(5:6:end, nr + 1);\n  thetaXdef = matUsCase1(2:6:end, nr + 1);\n  thetaYdef = matUsCase1(4:6:end, nr + 1);\n  thetaZdef = matUsCase1(6:6:end, nr + 1);\n  % Gosselin deformed coordinates solution\n  xdefG = def(1, :, nr);\n  ydefG = -def(2, :, nr);\n  % Plot\n  plot(xdef,  ydef,  ONSASline, 'linewidth', lw, 'markersize', ms);\n  plot(xdefG, ydefG,  Gline, 'linewidth', lw, 'markersize', ms);\nend\n\n<img src=\"../../assets/generated/RvsCyCd.png\" alt=\"plot check deformed configurations\" width=\"500\"/>","category":"section"},{"location":"examples/dragBeamReconfiguration/#Case-2:-case-with-drag-coefficient-formula-proposed-in-[this-reference](https://ascelibrary.org/doi/10.1061/%28ASCE%29HY.1943-7900.0000722)","page":"Reconfiguration beam","title":"Case 2: case with drag coefficient formula proposed in this reference","text":"Once _elemCrossSecParams_ is defined in the elements struct then the drag lift and pitch moment are defined with bluit-in functions. As consequence if we want to use the default drag coefficient the dragCoefFunction field must be set:\n\nelements(2).aeroCoefFunctions = {[], [], []};\n\nmoreover the drag formulation in this reference is valid with Re  2 x 10^5. Then the final load step, which is equivalent to the index in the velocity vector uydot_vec, is set to 5:\n\nanalysisSettings.finalTime = NR - 2;","category":"section"},{"location":"examples/dragBeamReconfiguration/#otherParams-2","page":"Reconfiguration beam","title":"otherParams","text":"The name of the problem and vtk format output are selected:\n\notherParams  = struct();\notherParams.problemName = 'staticReconfigurationCircleBuiltInDrag';","category":"section"},{"location":"examples/dragBeamReconfiguration/#Numeric-solution-2","page":"Reconfiguration beam","title":"Numeric solution","text":"[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUsCase2, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nthe report is generated\n\noutputReport(modelProperties.outputDir, modelProperties.problemName);\n\nDeformed configurations for different cauchy numbers\n\nfor nr = 1:analysisSettings.finalTime\n  % Numerical deformed coordinates solution\n  xdefCase2 = xref + matUsCase2(1:6:end, nr + 1);\n  ydefCase2 = yref + matUsCase2(3:6:end, nr + 1);\n  zdefCase2 = zref + matUsCase2(5:6:end, nr + 1);\n  thetaXdefCase2 = matUsCase2(2:6:end, nr + 1);\n  thetaYdefCase2 = matUsCase2(4:6:end, nr + 1);\n  thetaZdefCase2 = matUsCase2(6:6:end, nr + 1);\n  % Plot\n  plot(xdefCase2,  ydefCase2,  ONSASlineBuiltInDrag, 'linewidth', lw, 'markersize', ms);\nend\nlegend('Gosselin2010(cd = 1.2)', 'ONSAS(cd = 1.2)', 'ONSAS(Built-in c_d)');\nlabx = xlabel('x [m]');\nlaby = ylabel('y [m]');\nset(legend, 'linewidth', axislw, 'fontsize', legendFontSize, 'location', 'eastOutside');\nset(gca, 'linewidth', axislw, 'fontsize', curveFontSize);\nset(labx, 'FontSize', axisFontSize);\nset(laby, 'FontSize', axisFontSize);\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  figure(3);\n  print('output/defPlots.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\n<img src=\"../../assets/generated/defPlots.png\" alt=\"plot check deformed configurations\" width=\"500\"/>","category":"section"},{"location":"examples/dragBeamReconfiguration/#Case-3:-Dynamic-Analysis-Considering-Vortex-Induced-Vibrations-(VIV)","page":"Reconfiguration beam","title":"Case 3: Dynamic Analysis Considering Vortex-Induced Vibrations (VIV)","text":"<img src=\"../../assets/dragBeamReconfiguration/VIVilus.svg\" alt=\"general sketch VIV case\" width=\"450\"/>\n\nIn this case, we extend the analysis to include dynamic effects and Vortex-Induced Vibrations (VIV) on the cantilever beam, according to the formulation proposed in (Villié, et.al., 2024).","category":"section"},{"location":"examples/dragBeamReconfiguration/#elements-2","page":"Reconfiguration beam","title":"elements","text":"The beam is subjected to a constant fluid flow in c_2, which induces drag and lift forces. The aerodynamic coefficients for drag and lift are defined using the dragCircular and liftCoefVIV functions, respectively.\n\nelements(2).aeroCoefFunctions = {'dragCircular', 'liftCoefVIV', []};","category":"section"},{"location":"examples/dragBeamReconfiguration/#initial-Conditions-2","page":"Reconfiguration beam","title":"initial Conditions","text":"Initial conditions are derived from Case 1 at step NR - 3 of the previous static analysis, inducing VIV effects in the static equilibrium for the same drag forces. Null velocity and accelerations are set by default:\n\ninitialConds    = struct();\ninitialConds.U  = matUsCase1(:,  end - 3);\n\nWe set initial values for the in-line and cross-flow wake variables:\n\ndofsWakeVariablesPerElement = 2;\nelementQ0 = (2 * ((1:numElements)' / numElements) - 1) * 0.001;\ninitialConds.Q0 = repelem(elementQ0, dofsWakeVariablesPerElement);\nelementP0 = (2 * ((1:numElements)' / numElements) - 1) * 0.002;\ninitialConds.P0 = repelem(elementP0, dofsWakeVariablesPerElement);","category":"section"},{"location":"examples/dragBeamReconfiguration/#analysisSettings-2","page":"Reconfiguration beam","title":"analysisSettings","text":"The alpha-HHT algorithm is set with the following tolerances, time step, and final time:\n\nanalysisSettings = struct();\nanalysisSettings.finalTime = 0.4;\nanalysisSettings.deltaT = 0.01;\nanalysisSettings.methodName = 'alphaHHT';\nanalysisSettings.stopTolIts = 15;\nanalysisSettings.stopTolDeltau = 0;\nanalysisSettings.stopTolForces = 1e-5;\n\nThe constant velocity field corresponding to NR - 3 step is set as well as density and viscosity of the fluid:\n\nanalysisSettings.fluidProps = {rhoF; nuF; 'windVelCircDynamic'};\n\nThe following parameters are set to configure the dynamic analysis considering VIV. The analysisSettings.crossFlowVIVBool parameter enables the consideration of cross-flow VIV in the analysis. The analysisSettings.inLineVIVBool parameter determines whether in-line VIV is considered, and it is set to true in this case. Lastly, the analysisSettings.addedMassBool parameter accounts for the added mass effect for the fluid forces computation.\n\nanalysisSettings.crossFlowVIVBool = true;\nanalysisSettings.inLineVIVBool = true;\nanalysisSettings.addedMassBool = true;","category":"section"},{"location":"examples/dragBeamReconfiguration/#otherParams-3","page":"Reconfiguration beam","title":"otherParams","text":"The name of the problem is set and VTK output is exported to generate an animation:\n\notherParams = struct();\notherParams.problemName = 'vivBeamReconfiguration';\notherParams.plots_format = '';","category":"section"},{"location":"examples/dragBeamReconfiguration/#Numeric-solution-3","page":"Reconfiguration beam","title":"Numeric solution","text":"[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n[matUsDynamic, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nEvolution of displacements of node A\n\nfinalNodeIndex  = numElements + 1;\nzDisplacement   = matUsDynamic(5:6:end, :);\ntimeVector      = 0:analysisSettings.deltaT:analysisSettings.finalTime;\nfigure;\nplot(timeVector, zDisplacement(finalNodeIndex, :), 'b-', 'LineWidth', 2);\nxlabel('Time [s]');\nylabel('Displacement in z [m]');\ntitle('Displacement in z at A');\ngrid on;\nset(gca, 'linewidth', axislw, 'fontsize', curveFontSize);\nset(get(gca, 'xlabel'), 'FontSize', axisFontSize);\nset(get(gca, 'ylabel'), 'FontSize', axisFontSize);\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  print('output/zDisplacementVIV.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\n<img src=\"../../assets/generated/zDisplacementVIV.png\" alt=\"Displacemnts in z direction of node A\" width=\"500\"/>\n\n<img src=\"https://github.com/ONSAS/ONSAS/blob/master/docs/src/assets/dragBeamReconfiguration/vivDragReconfigurartion.gif?raw=true\" alt=\"viv animation\">","category":"section"},{"location":"examples/dragBeamReconfiguration/#Verification-boolean","page":"Reconfiguration beam","title":"Verification boolean","text":"vecDifDeform =  [norm(ydef - ydefG(1:numElements * 10:end)'); ...\n                 norm(xdef - xdefG(1:numElements * 10:end)')];\nverifBooleanDef =  vecDifDeform <=  2e-2 * L;\nverifBooleanR = abs(R(end) - resudrag(end, 2)) <  5e-3;\nverifBooleanV = abs(zDisplacement(end, 38) - (-7.4e-03)) <  (7.4e-03 * 1e-1);\nverifBoolean = verifBooleanR && verifBooleanV && all(verifBooleanDef);","category":"section"},{"location":"creatingModels/#Creating-structural-models","page":"Creating Models","title":"Creating structural models","text":"The data and properties of each structural model are defined through a set of definitions in a .m script. These properties are stored in struct data structures. The following structs must be defined and provided as input to the ONSAS function in this order:\n\nmaterials\nelements\nboundaryConds\ninitialConds\nmesh\nnumericalMethod\notherParams\n\nEach struct has its own fields with specific names, used to store each corresponding property or information. Each field is obtained or assigned using structName.fieldName. A description of each struct and its fields follows at next. It is highly recommended to read the current sectiong following one of the examples presented in the documentation. ","category":"section"},{"location":"creatingModels/#materials","page":"Creating Models","title":"materials","text":"The materials vector of structs contains at each entry i the information of the i-th material used in the mesh.conecCell for each element.","category":"section"},{"location":"creatingModels/#materials(i).modelName","page":"Creating Models","title":"materials(i).modelName","text":"This is field contains a string of the material model used to compute the internal forces of the structure. The models implemented in ONSAS are:\n\n'elastic-linear': used for linear behavior with small strains and small displacements. The scalar parameters of this model are p_1=E the Young modulus and p_2=nu the Poisson's ratio.\n'elastic-SVK': used for a Saint-Venant-Kirchhoff material where the parameters p_1 and p_2 are the Lamé parameters with the strain-energy density function given by the following equation (where textbfE is the Green-Lagrange strain tensor)\n\nPsi( textbfE ) = fracp_12 tr(textbfE)^2 + p_2 tr(textbfE^2)\nquad\np_1 = frac E nu  (1+nu) (1-2nu) \nquad\np_2 = frac E  2 (1+nu) \n\n'elastic-NHC': used for a Neo-Hookean compressible material. The model implemented is given by\n\nPsi( textbfC ) = fracp_12 ( tr(textbfC)-3 -2 L( sqrtdet(textbfC) ) ) + fracp_22 left( sqrtdet(textbfC)-1 right)^2\n quad\n p_1 = frac E  2 (1+nu) \n quad\n p_2 = frac E  3 (1-2 nu) \n\n'elastic-rotEngStr': used for 1D elements (truss or frame) under large displacements.\n'elastic-rotLogStr': used for 1D elements (truss) under large displacements.\n'plastic': an ElastoPlastic material with isotropic hardening given by the von mises flow rule for the plane strain element. The parameters are introduced as: p_1=E , p_2 = K and p_3=sigma_Y0.\n'plastic-rotEngStr': an ElastoPlastic material .\n'plastic-rotLogStr': an ElastoPlastic material .","category":"section"},{"location":"creatingModels/#materials(i).modelParams","page":"Creating Models","title":"materials(i).modelParams","text":"A vector with the properties of this material model.\n\n p_1 dots p_n_P \n\nwhere n_P is the number of parameters of the constitutive model and mathbfp is the vector of constitutive parameters.","category":"section"},{"location":"creatingModels/#materials(i).density","page":"Creating Models","title":"materials(i).density","text":"This is the scalar value of the density of the material.","category":"section"},{"location":"creatingModels/#materials(i).nodalMass","page":"Creating Models","title":"materials(i).nodalMass","text":"This fields sets a vector of nodal masses components m_x m_y m_z that is assigned to nodes.","category":"section"},{"location":"creatingModels/#elements","page":"Creating Models","title":"elements","text":"The elements vector of structs contains at each entry i the information of the i-th finite element type used in the mesh.conecCell for each element of the mesh.","category":"section"},{"location":"creatingModels/#elements(i).elemType","page":"Creating Models","title":"elements(i).elemType","text":"A string representing the type of element. The possible strings are: node, truss, frame, edge, triangle or tetrahedron.","category":"section"},{"location":"creatingModels/#elements(i).elemTypeParams","page":"Creating Models","title":"elements(i).elemTypeParams","text":"A scalar or vector with auxiliary parameters, required for some element types:\n\ntriangle vector with parameters, the first parameter is an integer indicating if plane stress (1) or plane strain (2) case is considered.","category":"section"},{"location":"creatingModels/#elements(i).massMatType","page":"Creating Models","title":"elements(i).massMatType","text":"The massMatType field sets, for frame or truss elements, whether consistent or lumped mass matrix is used for the inertial term in dynamic analyses. The massMatType field should be set as a string variable: 'consistent' or 'lumped',  and if it is not declared then by default the 'lumped' mass matrix is set.","category":"section"},{"location":"creatingModels/#elements(i).elemCrossSecParams","page":"Creating Models","title":"elements(i).elemCrossSecParams","text":"This is a cell structure with the information of the geometry of the element.","category":"section"},{"location":"creatingModels/#1D-elements","page":"Creating Models","title":"1D elements","text":"For truss or frame elements, this cell has two entries, first a string with a name of the type of cross section, and in the second entry a vector of real parameters setting the shape of that section:\n\n crossSectionTypeString   crossSectionParam_1 dots crossSectionParam_n  \n\nwith n being the number of parameters of the cross section type, and crossSectionTypeString the type of cross section. The possible cross section strings and their corresponding properties are:\n\ngeneric  :general sections, where areas and inertias are provided as parameters according to the vector: A  J  I_yy  I_zz  I_rho(11)  I_rho(22)  I_rho(33)   where A is the area, I_ii is the second moment of inertia of the cross-section respect to i direction, J is the polar moment of inertia and I_rho is the inertia tensor.\nrectangle: rectangular sections where thicknesses t_y and t_z are provided as the vector t_y t_z\ncircle : circular sections where diameter is provided.\npipe : circular hollow section where external and internal diameters are provided as first and second entries of the vector of elementCrossSecParams.\n\nFor edge elements the thickness is expected (for 2D load computations).\n\nSee the crossSectionProps.m function for more details.","category":"section"},{"location":"creatingModels/#2D-elements","page":"Creating Models","title":"2D elements","text":"For 2D elements such as triangle in this field a float number representing the thickness of the element is set.   ","category":"section"},{"location":"creatingModels/#elements(i).aeroCoefFunctions","page":"Creating Models","title":"elements(i).aeroCoefFunctions","text":"If a frame aerodynamic analysis is desired, the drag, lift and pitch moment functions should be defined using this field. This field should contain a cell with either the strings of the functions or the definition of anonymous functions for draf lif and pitch moment in that order. Each function must receive as first input the incidence angle and as second the Reynolds number. For some elemCrossSecParams like 'circle' internal built-in functions are set as default thus there is no need to set this field.","category":"section"},{"location":"creatingModels/#elements(i).chordVector","page":"Creating Models","title":"elements(i).chordVector","text":"A vector with the three coordinates of the aerodynamic chord vector (the system of coordinates considered for this is the local reference system at the undeformed configuration)","category":"section"},{"location":"creatingModels/#boundaryConds","page":"Creating Models","title":"boundaryConds","text":"The boundary condtion vector of structs contains at each entry i the information of the i-th boundary condtion used in the mesh.conecCell for each element.","category":"section"},{"location":"creatingModels/#boundaryConds(i).loadsCoordSys","page":"Creating Models","title":"boundaryConds(i).loadsCoordSys","text":"cell containing the coordinates system for the loads applied in each BC, each entry should be a 'global' string or a 'local', or an empty array if no load is applied in that BC setting [].","category":"section"},{"location":"creatingModels/#boundaryConds(i).loadsTimeFact","page":"Creating Models","title":"boundaryConds(i).loadsTimeFact","text":"cell with the inline function definitions of load factors of the loads applied of an empty array.","category":"section"},{"location":"creatingModels/#boundaryConds(i).loadsBaseVals","page":"Creating Models","title":"boundaryConds(i).loadsBaseVals","text":"cell with the (row) vector of the components of the load case\n\n f_x   m_x  f_y  m_y  f_z  m_z \n\nwhere f_i are the components of forces and m_i are the moments. Both forces or moments are considered per unit of length in the case of truss/frame/edge elements, or per unit of area in the case of triangle.","category":"section"},{"location":"creatingModels/#boundaryConds(i).userLoadsFileName","page":"Creating Models","title":"boundaryConds(i).userLoadsFileName","text":"string with the filename of the .m function file provided by the user that can be used to apply forces not given by time-varying loadFactors. This function file should be placed in the example folder and it must receive two arguments:  t (the time) and UsCell (a cell with: {the current displacement, velocity and acceleration} ). The function should one forces vector with the size of all the degrees of freedom of the problem (in global coordinates).","category":"section"},{"location":"creatingModels/#boundaryConds(i).imposDispDofs","page":"Creating Models","title":"boundaryConds(i).imposDispDofs","text":"vector with the local degrees of freedom imposed (integers from 1 to 6)","category":"section"},{"location":"creatingModels/#boundaryConds(i).imposDispVals","page":"Creating Models","title":"boundaryConds(i).imposDispVals","text":"vector with the values of the imposed displacements at the corresponding imposDispDofs.","category":"section"},{"location":"creatingModels/#boundaryConds(i).springDofs","page":"Creating Models","title":"boundaryConds(i).springDofs","text":"vector with the local degrees of freedom of the node with springs (integers from 1 to 6)","category":"section"},{"location":"creatingModels/#boundaryConds(i).springVals","page":"Creating Models","title":"boundaryConds(i).springVals","text":"vector with the values of the springs stiffnesses.","category":"section"},{"location":"creatingModels/#The-mesh-struct","page":"Creating Models","title":"The mesh struct","text":"The mesh struct contains the finite element mesh information.","category":"section"},{"location":"creatingModels/#mesh.nodesCoords","page":"Creating Models","title":"mesh.nodesCoords","text":"matrix with the coordinates of all the nodes of the mesh. The i-th row contains the three coordinates of the node i: x_i   y_i  z_i,","category":"section"},{"location":"creatingModels/#mesh.conecCell","page":"Creating Models","title":"mesh.conecCell","text":"cell array with the elements and node-connectivity information. The i1 entry contains the vector with the MEB (Material, Element, boundaryConds) indexes and the nodes of the i-th element. The structure of the vector at each entry of the cell is:\n\n  materialInd  elementInd  boundaryCondInd  node_1 dots node_n \n\nwhere the first three indexes are natural numbers and n is the number of nodes required by the type of element. If no property is assigned the 0 index can be used, for instance, nodes used to introduced loads should be defined with materialIndex = 0.","category":"section"},{"location":"creatingModels/#The-initialConds-struct","page":"Creating Models","title":"The initialConds struct","text":"If initial conditions are homogeneous, then an empty struct should be defined using initialConds = struct() ;. Otherwise the fields that can be set are:\n\ninitialConds.U: a vector of the displacements at time 0.\ninitialConds.Udot: a vector of the velocities  at time 0.\ninitialConds.Udotdot: a vector of the accelerations at time 0.","category":"section"},{"location":"creatingModels/#The-analysisSettings-struct","page":"Creating Models","title":"The analysisSettings struct","text":"This struct contains the parameters required to apply the numerical method for the resolution of the nonlinear equations:\n\nmethodName: string with the name of the method used: 'newtonRaphson','arcLength', 'newmark','alphaHHT'.\nstopTolDeltau: float with tolerance for convergence in relative norm of displacements increment\nstopTolForces: float with tolerance for convergence in relative norm of residual loads\nstopTolIts: integer with maximum number of iterations per time step\ndeltaT: time step\nfinalTime: final time of simulation\nincremArcLen: radius of the cylinder for the arcLength method. if scalar is provided then this is fixed during all times. if a vector is provided then for each time t_i the entry i of the vector will be used as radius. Default is 015. \nALdominantDOF: if this is not set or set as [] (zero) then the cylindical ArcLength method based on DeSouzaNeto's Computational Methods for plasticity is used, if a non-empty vector is provided, then the dominant dof arc length variant based on Jirásek & Bazant, Inelastic Analysis of Structures, 2002, Chapter 22, is used, the first entry is the dof and the second the scaling factor\ndeltaNM: delta parameter of newmark method. If this parameter is not declared then the classic Trapezoidal Newmark delta = 12 is set.\nalphaNM: alpha parameter of newmark method. If this parameter is not declared then the classic  Trapezoidal Newmark alpha = 14 is set.\nalphaHHT: alpha parameter of alpha-HHT method. If this parameter is not declared then alpha=-005 is set.\nposVariableLoadBC: (parameter used by the arcLength method) this parameter is an integer with the entry of the boundaryConds cell corresponding with the loads vector affected by the load factor. Default is [].\niniDeltaLamb: (parameter used by the arcLength method) this parameter sets the initial increment for the load factor lambda. Default is 1e-3.\n\nanother additional optional parameters are:\n\nbooleanSelfWeight: a boolean indicating if self weight loads are considered or not. The loads are computed using the density of the material and in the -z global direction.\niniMatUs: a matrix with initial solutions for each time step.\naddedMassBoolean: if this parameter is set 'true' the fluid density is considered in the intertial forces term for frame elements.\n\nthe aerodynamic-frame element parameters set are\n\nfluidProps: is a row cell with the density rho_f, viscosity nu_f and the function with the fluid velocity  \n\n rho_f  nu_f  fluidVelocity\n\ngeometricNonLinearAero: a boolean parameter. If it is set as true geometric nonlinearity (or reconfiguration) is considered in the computation of the aerodynamic forces vector of all frame elements of the model.\nnumGaussPointsAeroForce:  number of Gauss integration points per element for the aerodynamic forces vector. Default is 4. \ncomputeAeroStiffnessMatrix: a boolean to compute the aerodynamic forces stiffness matrix using a central difference algorithm. Default is 'false', since can affect performance.  ","category":"section"},{"location":"creatingModels/#The-otherParams-struct","page":"Creating Models","title":"The otherParams struct","text":"problemName: string with the name of the problem, to be used in outputs.\nplots_format: string indicating the format of the output. Use 'vtk' for vtk output. default: no output.\nplots_deltaTs_separation: integer number N such that the time between vtk plots is N x deltaT.\ncontrolDofs: matrix with information of the degrees of freedom to compute and control. Each row should contain this form: [ node localdof ].\nstoreBoolean: boolean to store the results of the current iteration such as the displacements, tangent matrices, normal forces and stresses. [default: 1]\nnodalDispDamping: scalar value of a linear viscous damping factor applied for all the displacement degrees of freedom [default: 0]","category":"section"},{"location":"examples/uniaxialCompression/#Uniaxial-Compression-example","page":"Uniaxial compression","title":"Uniaxial Compression example","text":"(Image: Octave script)\n\nIn this tutorial example an hyperelastic solid is submitted to a uniaxial compression test. The geometry and tension applied are shown in the figure, where the Lx, Ly and Lz are the dimensions. A nominal compression tension p is applied on the face x=Lx, as a nominal tension. Non-friction contact boundary conditions are considered on faces x=0, y=0 and z=0.\n\n<img src=\"../../assets/uniaxialCompression/diagramSolidUniaxialCompression.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"section"},{"location":"examples/uniaxialCompression/#Analytic-solution","page":"Uniaxial compression","title":"Analytic solution","text":"Let us consider that a uniform deformation is produced, with a nonzero axial stretch alpha and nonzero transversal stretch beta. The corresponding deformation gradient and Green-Lagrange strain tensors are given by:\n\ntextbfF = left beginmatrix alpha  0  0  0  beta  0  0  0  beta endmatrix right\nqquad\ntextbfE = frac12(textbfC - textbfI) = left  beginmatrix frac12 left(alpha^2 -1right)  0  0  0   frac12 left(beta^2 -1right)  0  0  0   frac12 left(beta^2 -1right) endmatrix\nright\n\nwhere alpha = (1+u_xL_x) and beta = (1+u_yL_y), with u_x and u_y the linear displacements at X=(L_xL_yL_z=L_y).\n\nThe neo-Hookean elastic strain energy potential Psi is given by:\n\nPsi(mathbfC=textbfF^TtextbfF) = fracmu2(I_1 -2ln(J)) + fracK2 ( J -1 )^2\n\nwhere I_1 = mathrmtr(mathbfC) is the first invariant, J = sqrtdet(mathbfC) and K and mu are the bulk and shear material parameters, respectively.\n\nThe second Piola-Kirchhoff tensor is given by:\n\ntextbfS( mathbfC ) = mu (textbfI - mathbfC^-1) + K (J(J-1)mathbfC^-1)\n\nthen, on the one hand, using the relation textbfP=textbfFtextbfS, the P_xx nominal stress component is obtained and equaled to the applied compression:\n\nP_xx( muK ) =\nalpha left(\nmu -  fracmualpha^2 + fracKbeta^2alpha (beta^2 alpha -1)\nright) = - p\n\nand on the other hand, the P_yy and P_zz components are obtained and equaled to zero:\n\nP_yy( muK ) =\nbeta left(\nmu -  fracmubeta^2 + K (alpha^2beta^2 - alpha)\nright) = 0","category":"section"},{"location":"examples/uniaxialCompression/#Numerical-solution","page":"Uniaxial compression","title":"Numerical solution","text":"Before defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined.\n\nclose all;\nif ~strcmp(getenv('TESTS_RUN'), 'yes')\n  clear all;\nend\naddpath(genpath([pwd '/../../src']));\nE = 1;\nnu = 0.3;\np = -5;\nLx = 2;\nLy = 1;\nLz = 1;","category":"section"},{"location":"examples/uniaxialCompression/#MEB-parameters","page":"Uniaxial compression","title":"MEB parameters","text":"","category":"section"},{"location":"examples/uniaxialCompression/#materials","page":"Uniaxial compression","title":"materials","text":"The material of the solid considered is a neo-Hookean model with lambda, mu and bulk(K) parameters:\n\nlambda = E * nu / ((1 + nu) * (1 - 2 * nu));\nmu = E / (2 * (1 + nu));\nbulk = E / (3 * (1 - 2 * nu));\n\nsince only one material is considered, a scalar struct is defined as follows\n\nmaterials                 = struct();\nmaterials.modelName  = 'NHC';\nmaterials.modelParams = [mu bulk];","category":"section"},{"location":"examples/uniaxialCompression/#elements","page":"Uniaxial compression","title":"elements","text":"In this model two kinds of elements are used: tetrahedron for the solid and triangle for introducing the external loads. Since two kinds of elements are used, the struct have length 2:\n\nelements             = struct();\nelements(1).elemType = 'triangle';\nelements(2).elemType = 'tetrahedron';\nelements(2).elemTypeParams = [2];","category":"section"},{"location":"examples/uniaxialCompression/#boundaryConds","page":"Uniaxial compression","title":"boundaryConds","text":"in this case four BCs are considered, one corresponding to a load and three to displacements. the first BC introduced is a load, then the coordinate system, loadfactor time function and base load vector are defined\n\nboundaryConds                  = struct();\nboundaryConds(1).loadsCoordSys = 'global';\nboundaryConds(1).loadsTimeFact = @(t) p * t;\nboundaryConds(1).loadsBaseVals = [1 0 0 0 0 0];\n\nthe other BCs have imposed displacements\n\nboundaryConds(2).imposDispDofs = [1];\nboundaryConds(2).imposDispVals =  0;\nboundaryConds(3).imposDispDofs = [3];\nboundaryConds(3).imposDispVals =  0;\nboundaryConds(4).imposDispDofs = [5];\nboundaryConds(4).imposDispVals =  0;","category":"section"},{"location":"examples/uniaxialCompression/#Mesh","page":"Uniaxial compression","title":"Mesh","text":"A simple hand-made 8-node mesh, with 6 tetrahedrons is considered\n\n<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/solidCubeMeshHTML.svg\" alt=\"mesh diagram\" width=\"500\"/>\n\n\\begin{center}\n\\def\\svgwidth{0.6\\textwidth}\n\\input{solidCubeMeshPDF.pdf_tex}\n\\end{center}\n\nThe node coordinates matrix is given by\n\nmesh             = struct();\nmesh.nodesCoords = [0    0    0; ...\n                    0    0   Lz; ...\n                    0   Ly   Lz; ...\n                    0   Ly    0; ...\n                    Lx   0    0; ...\n                    Lx   0   Lz; ...\n                    Lx  Ly   Lz; ...\n                    Lx  Ly    0];\n\nand the connectivity cell is defined as follows with the four MEB parameters for each element followed by the indexes of the nodes of each element. All the eight triangle elements are considered with no material (since they are used only to include load) and the following six elements are solid neo-Hookean material tetrahedrons.\n\nmesh.conecCell = {[0 1 1     5 8 6]; ... % loaded face\n                  [0 1 1     6 8 7]; ... % loaded face\n                  [0 1 2     4 1 2]; ... % x=0 supp face\n                  [0 1 2     4 2 3]; ... % x=0 supp face\n                  [0 1 3     6 2 1]; ... % y=0 supp face\n                  [0 1 3     6 1 5]; ... % y=0 supp face\n                  [0 1 4     1 4 5]; ... % z=0 supp face\n                  [0 1 4     4 8 5]; ... % z=0 supp face\n                  [1 2 0     1 4 2 6]; ... % tetrahedron\n                  [1 2 0     6 2 3 4]; ... % tetrahedron\n                  [1 2 0     4 3 6 7]; ... % tetrahedron\n                  [1 2 0     4 1 5 6]; ... % tetrahedron\n                  [1 2 0     4 6 5 8]; ... % tetrahedron\n                  [1 2 0     4 7 6 8]  ... % tetrahedron\n                 };","category":"section"},{"location":"examples/uniaxialCompression/#initialConds","page":"Uniaxial compression","title":"initialConds","text":"since no initial non-homogeneous initial conditions are used, an empty struct is used .\n\ninitialConds = struct();","category":"section"},{"location":"examples/uniaxialCompression/#Analysis-parameters","page":"Uniaxial compression","title":"Analysis parameters","text":"analysisSettings               = struct();\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.stopTolIts    = 30;\nanalysisSettings.stopTolDeltau = 1.0e-8;\nanalysisSettings.stopTolForces = 1.0e-8;\nanalysisSettings.finalTime     = 1;\nanalysisSettings.deltaT        = .1;","category":"section"},{"location":"examples/uniaxialCompression/#Output-parameters","page":"Uniaxial compression","title":"Output parameters","text":"otherParams             = struct();\notherParams.problemName = 'uniaxialCompression_HandMadeMesh';\notherParams.plots_format = 'vtk';\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nThe displacement in x of node 7 is computed:\n\ncontrolDispsValsCase1 = matUs(6 * 6 + 1, :);\nloadFactorsCase1 = loadFactorsMat;","category":"section"},{"location":"examples/uniaxialCompression/#Analytic-solution-computation","page":"Uniaxial compression","title":"Analytic solution computation","text":"The numerical values of beta and alpha for each load step are:\n\nalphas       = (Lx + matUs(6 * 6 + 1, :)) / Lx;\nbetas        = (Ly + matUs(6 * 6 + 3, :)) / Ly;\n\nand the corresponding analytic nominal tension is obtained\n\nanalyticFuncPxx = @(alphas, betas) mu * alphas - mu * 1 ./ alphas + bulk * betas.^2 .* (alphas .* betas.^2 - 1);\nanalyticFuncPyy = @(alphas, betas) betas .* mu  - mu * 1 ./ betas + bulk * betas .* (alphas.^2 .* betas.^2 - alphas);\nanalyticPxx = analyticFuncPxx(alphas, betas);\nanalyticPyy = analyticFuncPyy(alphas, betas);\n\nThe error and the verif boolean are computed\n\naux1 = loadFactorsCase1' - analyticPxx;\ntolerance = 1e-6;\nverifBoolean = (norm(aux1) / norm(analyticPxx) < 1e-6) && (norm(analyticPyy) < tolerance);","category":"section"},{"location":"examples/uniaxialCompression/#Plot","page":"Uniaxial compression","title":"Plot","text":"The numerical and analytic solutions are plotted.\n\nlw = 2.0;\nms = 11;\nplotfontsize = 18;\nfigure;\nhold on;\ngrid on;\nplot(controlDispsValsCase1, loadFactorsCase1, 'r-x', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsValsCase1, analyticPxx,  'g-s', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('Displacement');\nlaby = ylabel('\\lambda(t)');\nlegend('Numeric', 'Analytic', 'location', 'SouthEast');\nset(gca, 'linewidth', 1.0, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\ntitle('uniaxial compression test');\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  print('./output/verifCompression.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\n<img src=\"../../assets/generated/verifCompression.png\" alt=\"validation plot\" width=\"500\"/>","category":"section"},{"location":"examples/uniaxialExtension/#Uniaxial-Extension-Solid-example","page":"Uniaxial extension","title":"Uniaxial Extension Solid example","text":"(Image: Octave script)\n\nIn this tutorial example an elastic solid is submitted to a uniaxial extension test. The problem is inspired by Exercise 4 from section 6.5 in (Holzapfel,2000). The geometry and tension applied are shown in the figure, where the Lx, Ly and Lz are the dimensions and the tension p is applied on the face x=Lx, as nominal traction (see (Holzapfel,2000)).\n\n<img src=\"../../assets/diagramSolidUniaxial.svg\" alt=\"structure diagram\" width=\"500\"/>","category":"section"},{"location":"examples/uniaxialExtension/#Analytic-solution","page":"Uniaxial extension","title":"Analytic solution","text":"Let us consider that a uniform deformation is produced, with a nonzero axial stretch alpha and nonzero transversal stretch beta. The corresponding deformation gradient and Green-Lagrange strain tensor are given by:\n\ntextbfF = left beginmatrix alpha  0  0  0  beta  0  0  0  beta endmatrix right\nqquad\ntextbfE = left  beginmatrix frac12 left(alpha^2 -1right)  0  0  0   frac12 left(beta^2 -1right)  0  0  0   frac12 left(beta^2 -1right) endmatrix\nright\n\nThe second Piola-Kirchhoff tensor textbfS is given by\n\ntextbfS( textbfE ) = p_1 tr(textbfE) textbfI + 2 p_2 textbfE\n\nthen, using the relation textbfP=textbfFtextbfS, the P_yy component is computed and set to zero (using the boundary conditions)\n\nP_yy( textbfE ) =\np_1 beta left(\nfrac12 left(alpha^2 -1 right) + left( beta^2 -1right)\nright) + 2 p_2 beta (frac12 left(beta^2 -1 right)) = 0\n\nthen, using that betaneq0 (since textdet( textbfF ) neq0), we obtain\n\np_1 frac12 left(alpha^2 -1 right)\n= - (p_1+p_2) left(beta^2 -1 right)\n\nthen using the relation between the Lamé parameters p_2 and p_1 and the Young modulus and Poisson ratio, we obtain:\n\nleft(beta^2 -1 right) = -nu left(alpha^2 -1 right)\n\nThe axial component of the nominal stress is\n\nP_xx( textbfE ) =\np_1 alpha left(\nfrac12 left(alpha^2 -1 right) + left( beta^2 -1right)\nright) + 2 p_2 alpha (frac12 left(alpha^2 -1 right)) = 0\n\nand substituting we obtain\n\nP_xx( alpha ) =\np_1 alpha frac1-2nu2 left(alpha^2 -1 right) + p_2 alpha left(alpha^2 -1 right) =\nleft( fracE nu(1+nu)2  + fracE(1+nu)2 right)  alpha left(alpha^2 -1 right)\n\nthus, considering the axial displacement u and using the stretch definition alpha = (1+uLx), we obtain\n\nP_xx( u ) =\nfracE2  left( left( 1+fracuLx right)^3 - left( 1+ fracuLx right) right)\n\nwhere u is the x displacement of the points located on face x=Lx.","category":"section"},{"location":"examples/uniaxialExtension/#Numerical-solution:-case-1","page":"Uniaxial extension","title":"Numerical solution: case 1","text":"\n\nBefore defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined.\n\nclose all;\n  clear all;\naddpath(genpath([pwd '/../../src']));\nE = 1;\nnu = 0.3;\np = 3;\nLx = 2;\nLy = 1;\nLz = 1;","category":"section"},{"location":"examples/uniaxialExtension/#MEB-parameters","page":"Uniaxial extension","title":"MEB parameters","text":"","category":"section"},{"location":"examples/uniaxialExtension/#materials","page":"Uniaxial extension","title":"materials","text":"The material of the solid considered is the Saint-Venant-Kirchhoff with Lamé parameters computed as\n\nlambda = E * nu / ((1 + nu) * (1 - 2 * nu));\nmu = E / (2 * (1 + nu));\n\nsince only one material is considered, a scalar struct is defined as follows\n\nmaterials             = struct();\nmaterials.modelName   = 'SVK';\nmaterials.modelParams = [lambda mu];","category":"section"},{"location":"examples/uniaxialExtension/#elements","page":"Uniaxial extension","title":"elements","text":"In this model two kinds of elements are used: tetrahedron for the solid and triangle for introducing the external loads. Since two kinds of elements are used, the struct have length 2:\n\nelements             = struct();\nelements(1).elemType = 'triangle';\nelements(2).elemType = 'tetrahedron';","category":"section"},{"location":"examples/uniaxialExtension/#boundaryConds","page":"Uniaxial extension","title":"boundaryConds","text":"in this case four BCs are considered, one corresponding to a load and three to displacements. the first BC introduced is a load, then the coordinate system, loadfactor time function and base load vector are defined\n\nboundaryConditions             = struct();\nboundaryConds(1).loadsCoordSys = 'global';\nboundaryConds(1).loadsTimeFact = @(t) p * t;\nboundaryConds(1).loadsBaseVals = [1 0 0 0 0 0];\n\nthe other BCs have imposed displacements\n\nboundaryConds(2).imposDispDofs = [1];\nboundaryConds(2).imposDispVals =  0;\nboundaryConds(3).imposDispDofs = [3];\nboundaryConds(3).imposDispVals =  0;\nboundaryConds(4).imposDispDofs = [5];\nboundaryConds(4).imposDispVals =  0;","category":"section"},{"location":"examples/uniaxialExtension/#initialConds","page":"Uniaxial extension","title":"initialConds","text":"since no initial non-homogeneous initial conditions are used, an empty struct is used .\n\ninitialConds = struct();","category":"section"},{"location":"examples/uniaxialExtension/#Mesh","page":"Uniaxial extension","title":"Mesh","text":"A simple hand-made 8-node mesh, with 6 tetrahedrons is considered\n\n<img src=\"https://raw.githubusercontent.com/ONSAS/ONSAS_docs/master/docs/src/solidCubeMeshHTML.svg\" alt=\"mesh diagram\" width=\"500\"/>\n\n\\begin{center}\n\\def\\svgwidth{0.6\\textwidth}\n\\input{solidCubeMeshPDF.pdf_tex}\n\\end{center}\n\nThe node coordinates matrix is given by the following\n\nmesh             = struct();\nmesh.nodesCoords = [0    0    0; ...\n                    0    0   Lz; ...\n                    0   Ly   Lz; ...\n                    0   Ly    0; ...\n                    Lx   0    0; ...\n                    Lx   0   Lz; ...\n                    Lx  Ly   Lz; ...\n                    Lx  Ly    0];\n\nand the connectivity cell is defined as follows with the four MEB parameters for each element followed by the indexes of the nodes of each element. All the eight triangle elements are considered with no material (since they are used only to include load) and the following six elements are solid SVK material tetrahedrons.\n\nmesh.conecCell = {[0 1 1     5 8 6]; ... % loaded face\n                  [0 1 1     6 8 7]; ... % loaded face\n                  [0 1 2     4 1 2]; ... % x=0 supp face\n                  [0 1 2     4 2 3]; ... % x=0 supp face\n                  [0 1 3     6 2 1]; ... % y=0 supp face\n                  [0 1 3     6 1 5]; ... % y=0 supp face\n                  [0 1 4     1 4 5]; ... % z=0 supp face\n                  [0 1 4     4 8 5]; ... % z=0 supp face\n                  [1 2 0     1 4 2 6]; ... % tetrahedron\n                  [1 2 0     6 2 3 4]; ... % tetrahedron\n                  [1 2 0     4 3 6 7]; ... % tetrahedron\n                  [1 2 0     4 1 5 6]; ... % tetrahedron\n                  [1 2 0     4 6 5 8]; ... % tetrahedron\n                  [1 2 0     4 7 6 8]  ... % tetrahedron\n                 };","category":"section"},{"location":"examples/uniaxialExtension/#Analysis-parameters","page":"Uniaxial extension","title":"Analysis parameters","text":"analysisSettings               = struct();\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.stopTolIts    = 30;\nanalysisSettings.stopTolDeltau = 1.0e-8;\nanalysisSettings.stopTolForces = 1.0e-8;\nanalysisSettings.finalTime      = 1;\nanalysisSettings.deltaT        = .125;","category":"section"},{"location":"examples/uniaxialExtension/#Output-parameters","page":"Uniaxial extension","title":"Output parameters","text":"otherParams              = struct();\notherParams.plots_format = 'vtk';\notherParams.problemName  = 'uniaxialExtension_HandMadeMesh';\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/uniaxialExtension/#Numeric-and-Analytic-solutions-computation","page":"Uniaxial extension","title":"Numeric and Analytic solutions computation","text":"The numerical displacements of the 7th node are computed, as well as the load factors applied\n\ncontrolDisps                 = matUs(6 * 6 + 1, :);\ncontrolDispsValsCase1        = controlDisps;\nloadFactorNumericalValsCase1 = loadFactorsMat;\n\nThe function of the analytic loadfactor for any displacement of node 7 is used\n\nanalyticFunc           = @(w) E * 0.5 * ((1 + w / Lx).^3 - (1 + w / Lx));\nanalyticVals = analyticFunc(controlDisps);\nloadFactorAnalyticalValsCase1 = analyticVals;","category":"section"},{"location":"examples/uniaxialExtension/#Numerical-solution:-case-2","page":"Uniaxial extension","title":"Numerical solution: case 2","text":"In this analysis case, the mesh information is read from a mesh file generated by the tool GMSH. The pressure is applied using local coordinates and the stiffness matrix is computed using the complex-step method.\n\notherParams.problemName = 'uniaxialExtension_GMSH_ComplexStep';\n\nthis auxiliar line sets the right path to the testing environment\n\nbase_msh = '';\n[mesh.nodesCoords, mesh.conecCell] = meshFileReader([base_msh 'geometry_uniaxialExtension.msh']);\nboundaryConds(1).loadsCoordSys = 'local';\nboundaryConds(1).loadsBaseVals = [0 0 0 0 1 0];\nelements(2).elemTypeParams = [2];\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, solutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\ncontrolDisps = matUs(6 * 6 + 1, :);\nanalyticVals = analyticFunc(controlDisps);\ncontrolDispsValsCase2         = controlDisps;\nloadFactorAnalyticalValsCase2 = analyticVals;\nloadFactorNumericalValsCase2  = loadFactorsMat;\naux1 = loadFactorNumericalValsCase1' - loadFactorAnalyticalValsCase1;\naux2 = loadFactorNumericalValsCase2' - loadFactorAnalyticalValsCase1;\n\nanalyticCheckTolerance = 1e-6;\nverifBoolean = ...\n      (norm(aux1) / norm(loadFactorNumericalValsCase1) < analyticCheckTolerance) && ...\n      (norm(aux2) / norm(loadFactorNumericalValsCase1) < analyticCheckTolerance);","category":"section"},{"location":"examples/uniaxialExtension/#Plot","page":"Uniaxial extension","title":"Plot","text":"The numerical and analytic solutions are plotted.\n\nlw = 2.0;\nms = 11;\nplotfontsize = 18;\nfigure;\nhold on;\ngrid on;\nplot(controlDispsValsCase1, loadFactorAnalyticalValsCase1, 'r-x', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsValsCase1, loadFactorNumericalValsCase1,  'k-o', 'linewidth', lw, 'markersize', ms);\nplot(controlDispsValsCase2, loadFactorNumericalValsCase2,  'g-s', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('Displacement');\nlaby = ylabel('\\lambda(t)');\nlegend('Analytic', 'Numeric-1', 'Numeric-2', 'location', 'North');\nset(gca, 'linewidth', 1.0, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\ntitle('uniaxial extension test');\nif length(getenv('TESTS_RUN')) > 0 && strcmp(getenv('TESTS_RUN'), 'yes')\n  fprintf('\\ngenerating output png for docs.\\n');\n  print('output/verifUniaxial.png', '-dpng');\nelse\n  fprintf('\\n === NOT in docs workflow. ===\\n');\nend\n\n<img src=\"../../assets/generated/verifUniaxial.png\" alt=\"plot check\" width=\"500\"/>","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"(Image: tests) (Image: License)","category":"section"},{"location":"#What-is-ONSAS?","page":"Home","title":"What is ONSAS?","text":"ONSAS is an Open Nonlinear Structural Analysis Solver for GNU-Octave/Matlab. It consists in a set of implementations of numerical methods for static/dynamic and linear/non-linear analysis of structures. The first version was developed for educational purposes and published in a Structural Analysis handbook for a graduate course taught at the School of Engineering of Universidad de la República. The current version allows to perform a diverse set of simulations and it has been used in specific research applications.","category":"section"},{"location":"#Some-Publications-using-ONSAS","page":"Home","title":"Some Publications using ONSAS","text":"Journal articles using ONSAS:\n\n2024, A. Villié, M. Vanzulli, J.M. Pérez Zerpa, J. Vétel, S. Etienne, F.P. Gosselin, Modeling vortex-induced vibrations of branched structures by coupling a 3D-corotational frame finite element formulation with wake-oscillators, Journal of Fluids and Structures url\n2023, M. Vanzulli, J. M. Pérez Zerpa, A co-rotational formulation for quasi-steady aerodynamic nonlinear analysis of frame structures, Heliyon url\n2022, M. Forets, D. Freire, J. M. Pérez Zerpa, Combining set propagation with finite element methods for time integration in transient solid mechanics problems, Computers & Structures url\n\nTheses using ONSAS:\n\n2021, M. Vanzulli, Implementación de una formulación corrotacional en dinámica no lineal y aplicación al modelado de líneas de transmisión eléctrica url\n2021, A. Teliz, Optimización de torres de alta tensión y su análisis frente a vientos de alta intensidad url\n\nConference full-articles using ONSAS:\n\n2025, S. Merlino, J.M. Pérez Zerpa, Implementación en Código Abierto de un Método para el Análisis Post-Colapso de Pórticos, MECOM AMCA proceeding","category":"section"},{"location":"#Some-academic-examples","page":"Home","title":"Some academic examples","text":"","category":"section"},{"location":"#A-deployable-ring","page":"Home","title":"A deployable ring","text":"This nonlinear static problem is introduced in (Goto et. al, 1992) and also considered in (Battini and Pacoste, 2002).\n\n<img src=\"https://github.com/ONSAS/ONSAS/blob/master/docs/src/assets/deployableRing.gif?raw=true\">","category":"section"},{"location":"#Right-Angle-Cantilever","page":"Home","title":"Right-Angle Cantilever","text":"This nonlinear dynamic analysis problem is introduced in (Simo and Vu-Quoc, 1988) and also considered as Example 1 in (Le et. al., 2014).\n\n<img src=\"https://github.com/ONSAS/ONSAS/blob/master/docs/src/assets/rightAngleCantilever.gif?raw=true\" alt=\"right-angle animation\">","category":"section"},{"location":"#A-simple-propeller-model","page":"Home","title":"A simple propeller model","text":"This problem is based on one of the examples presented in (Vanzulli and Pérez Zerpa, 2023).\n\n<img src=\"https://github.com/ONSAS/ONSAS/blob/master/docs/src/assets/propeller.gif?raw=true\" alt=\"propeller animation\">","category":"section"},{"location":"#A-tower-model","page":"Home","title":"A tower model","text":"<img src=\"https://github.com/ONSAS/ONSAS_docs/blob/master/gifs/tower.gif?raw=true\" alt=\"tower animation\">","category":"section"},{"location":"#A-beam/truss-pendulum","page":"Home","title":"A beam/truss pendulum","text":"<img src=\"https://raw.githubusercontent.com/mvanzulli/Tex_CorrotationalDynamicTL_TesisMV/main/Presentacion/Videos/3.gif\" alt=\"beam truss pendulum\">","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"You can publicly post in the discussion section or contact privately sending an e-mail to jorgepz [AT] fing.edu.uy .","category":"section"},{"location":"#Contributors-and-License","page":"Home","title":"Contributors and License","text":"","category":"section"},{"location":"#License","page":"Home","title":"License","text":"The code is distributed under a GNU-GPL 3.0 license.","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"The authorship of each version is (or tends to be) based on the criteria defined by the JOSS journal. The co-authors have collaborated in tasks such as: design, development or extensive documentation contributions.\n\nJorge M. Pérez Zerpa (1), leaded and managed the design and development of the code, developed the assembly functions, nonlinear truss element formulation, nonlinear static analysis function, designed and co-authored Newmark's method function, input and output functions, leaded the generation of the documentation.\nMauricio Vanzulli (2) co-developed the Newmark's method functions and scripts, developed input files for the dynamic analysis examples. Developed the nonlinear dynamic co-rotational frame element function, its validation and integration with the VIV function. \nJoaquín Viera (1), leaded the development of the Linear Analysis module and input files, collaborated in the design and development of the input reading and output generation modules, leaded the development of a GUI.\nSergio Merlino(1), leaded the development of the formulation for plastic analysis of frames considering hardening and softening hinges.\nAlexandre Villié (3) developed the current Vortex-Induced-Vibrations Wake Oscillator model. Also contributed in the validation of this function in the integration with the co-rotational frame element.\nMarcelo Forets (4) made relevant contributions to application of software technology tools, in particular, the documentation generation workflow. Contributed also to the implementation of the Neo-Hookean solid model.\nJean-Marc Battini (4), contributed functions for the computation of static internal forces of the nonlinear co-rotational frame element.\nJ. Bruno Bazzano (1), contributed to the design/development of the buckling analysis modules, co-designed the initial version of the code, developed and implemented validation examples, validated the HHT implementation.\n\nAffiliations:\n\nInstituto de Estructuras y Transporte, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay\nInstituto de Ingeniería Mecánica y Producción Industrial, Facultad de Ingeniería, Universidad de la República, Montevideo, Uruguay.\nDepartment of Mechanical Engineering, Polytechnique Montréal, Montréal, Canada.\nCentro Universitario Regional Este, Universidad de la República, Maldonado, Uruguay\nDepartment of Civil and Architectural Engineering, KTH Royal Institute of Technology, Stockholm, Sweden","category":"section"},{"location":"#Contributions-and-Acknowledgments","page":"Home","title":"Contributions and Acknowledgments","text":"Santiago Correa made contributions to examples, mainly beamLinearVibration, and corrected the expression of a parameter of the alpha-HHT method. Professor Sebastian Toro, provided functions for reading dxf files, which were part of ONSAS until version 0.2.6.\n\nProf. Pérez Zerpa would like to thank: Prof. Frédérick Gosselin for his support during the initial contributions of Alexandre Villié, Prof. Eduardo de Souza Neto for his comments on the arc-length norm computation, and Pablo Blanco, Gonzalo Ares and Gonzalo Maso Talou for so many discussions during early stages of the design of the code.\n\nThe development of ONSAS has been partially supported by funds provided by the following agencies/projects:\n\nComisión de Investigación Científica (CSIC) (project: Definición de estrategias para la aplicación de métodos de identificación de material al diagnóstico no invasivo de Cáncer de mama, manager, Prof. Pérez Zerpa),\nComisión Sectorial de Enseñanza (project: Rediseño de prácticas de enseñanza y evaluación en Resistencia de Materiales, manager, Prof. Pérez Zerpa),\nAgencia Nacional de Investigación e Innovación (project VIOLETA, code FSE_1_2016_1_131837, manager, Prof. Gabriel Usera).","category":"section"},{"location":"examples/beamLinearVibration/#Linear-Dynamic-Vibration-of-a-Simply-Supported-Beam","page":"Linear beam vibration","title":"Linear Dynamic Vibration of a Simply Supported Beam","text":"(Image: Octave script)\n\nIn this tutorial, the dynamic response of a simply supported beam is computed using ONSAS with the linear elastic and the co-rotational formulations. The aim of this example is to verify the numerical implementations using an analytic solution.\n\nThe problem consists in a beam with pinned nodes in both ends. Two loads of magnitude F(t) = f_o sin(wt) are applied in the middle point as it is shown in the figure, where f_o is the force magnitude amplitude and omega is the force angular frequency.\n\n<img src=\"../../assets/beamDynamicVibration.svg\" alt=\"structure diagram\" width=\"500\"/>\n\nBefore defining the structs, the workspace is cleaned and the ONSAS directory is added to the path\n\nclose all;\nif ~strcmp(getenv('TESTS_RUN'), 'yes')\n  clear all;\nend\naddpath(genpath([pwd '/../../src']));\n\nThe material scalar parameters are set.\n\nE = 200e9;\nnu = 0.3;\nrho = 700;\n\nThe cross-section of the beam is rectangular. The widths and other geometry scalar parameters are computed.\n\nl = 10;\nty = .3;\ntz = .1;                  % length of rectangular cross-section widths\nIyy = ty * tz^3 / 12;\nIzz = tz * ty^3 / 12; % bending inertias\nnumElements = 10; % Number of elements\n\nTime and applied force parameters are\n\nFo     = 100; % force magnitude (N)\nw      = 2; % force angular frequency (rad/s)\ntf     = 8; % s\ndeltat = 0.1; % s\n\nThe middle node is computed\n\nassert(rem(numElements, 2) == 0, 'the number of elements must be even.');\nappNode    = (numElements) / 2 + 1;\nappNodePos = (appNode - 1) * l / numElements;","category":"section"},{"location":"examples/beamLinearVibration/#Analytic-solution","page":"Linear beam vibration","title":"Analytic solution","text":"The governing equations for the deflection v of a beam with uniform cross-section, density and Young modulus with a transversal distributed applied load q is given by\n\nEI fracpartial^4 vpartial x^4(xt) + rho A fracpartial^2 vpartial t^2(xt) = q(xt)\n\nand using a Fourier decomposition and following the process explained in chapter 10 of Mechanical Vibrations (5th Edition; Rao Singiresu) we obtain the analytic solution for the displacement of our problem\n\nv(xt) = frac2forho A l sum_n=1^infty frac1w_n^2 - w^2 sinleft(fracn pi al right) sinleft(fracn pi xl right)sin(wt)\n\nwhere w_n are natural frequencies of the vibration for mode n (computed for each transversal direction).\n\nThe solution can be numerically computed setting a mesh of spatial poins and a vector of times\n\nts = 0:deltat:tf; % times vector\nxs = 0:l / numElements:l; % beam mesh\nns = 1:10; % modes\n\nAs well as the vector of natural frequencies\n\nwnY = ((ns * pi).^2) * sqrt(E * Izz / rho / (ty * tz) / (l^4)); % Natural frecuency direction Y\nwnZ = ((ns * pi).^2) * sqrt(E * Iyy / rho / (ty * tz) / (l^4)); % Natural frecuency direction Z\n\nThe values of the analytic solution are computed as\n\nanalyticDisY = 0;\nanalyticDisZ = 0;\nanalySolPos = appNodePos;  % the analytic solution is computed at the point of application of the load\nfor i = 1:length(ns)\n  analyticDisY = analyticDisY + (1 / (wnY(i)^2 - w^2)) * sin(i * analySolPos / l * pi) * sin(i * pi * appNodePos / l) * sin(w * ts)';\n  analyticDisZ = analyticDisZ + (1 / (wnZ(i)^2 - w^2)) * sin(i * analySolPos / l * pi) * sin(i * pi * appNodePos / l) * sin(w * ts)';\nend\nanalyticDisY = analyticDisY * (2 * Fo / (rho * ty * tz * l));\nanalyticDisZ = analyticDisZ * (2 * Fo / (rho * ty * tz * l));","category":"section"},{"location":"examples/beamLinearVibration/#Numerical-solution","page":"Linear beam vibration","title":"Numerical solution","text":"","category":"section"},{"location":"examples/beamLinearVibration/#MEB-parameters","page":"Linear beam vibration","title":"MEB parameters","text":"The modelling of the structure begins with the definition of the Material-Element-BoundaryConditions (MEB) parameters.","category":"section"},{"location":"examples/beamLinearVibration/#materials","page":"Linear beam vibration","title":"materials","text":"Since the example contains only one rod and no nodal masses are used, only one materials struct is defined. The first analysis is done using the co-rotational formulation\n\nmaterials = struct();\nmaterials.modelName  = 'elastic-rotEngStr';\nmaterials.modelParams = [E nu];\nmaterials.density         = rho;","category":"section"},{"location":"examples/beamLinearVibration/#elements","page":"Linear beam vibration","title":"elements","text":"Two different types of elements are considered, node and beam. The nodes will be assigned in the first entry (index 1) and the beam at index 2. The elemType field is then:\n\nelements = struct();\nelements(1).elemType = 'node';\nelements(2).elemType = 'frame';\n\nfor the crossSection, a frame element of rectangular-cross section with t_y and t_z dimensions in y and z directions is set, then the elemTypeGeometry field is:\n\nelements(2).elemCrossSecParams = { 'rectangle', [ty tz] };\n\nThe consistent mass approach is considered for the dynamic analysis\n\nelements(2).massMatType = 'consistent';","category":"section"},{"location":"examples/beamLinearVibration/#boundaryConditions","page":"Linear beam vibration","title":"boundaryConditions","text":"The elements are submitted to two different BC settings. The first BC corresponds to the fixed points\n\nboundaryConds = struct();\nboundaryConds(1).imposDispDofs = [1 2 3 5];\nboundaryConds(1).imposDispVals = [0 0 0 0];\n\nand the second corresponds to a time dependant external force\n\nboundaryConds(2).loadsCoordSys = 'global';\nboundaryConds(2).loadsTimeFact = @(t) Fo * sin(w * t);\nboundaryConds(2).loadsBaseVals = [0 0 1 0 1 0];","category":"section"},{"location":"examples/beamLinearVibration/#mesh-parameters","page":"Linear beam vibration","title":"mesh parameters","text":"The coordinates of the nodes of the mesh are given by the matrix:\n\nmesh = struct();\nmesh.nodesCoords = [(0:(numElements))' * l / numElements  zeros(numElements + 1, 2)];\n\nThe connectivity is introduced using the conecCell cell. Each entry of the cell contains a vector with the four indexes of the MEB parameters, followed by the indexes of the nodes of the element (node connectivity). For didactical purposes each element entry is commented. First the cell is initialized:\n\nmesh.conecCell = { };\n\nthen the first two nodes are defined, both with material zero (since nodes dont have material), the first element type (the first entry of the cells of the elements struct), and the first entry of the cells of the boundary conditions struct. Finally the node index is included.\n\nmesh.conecCell{ 1, 1 } = [0 1 1  1];\n\nthe following case only differs in the boundary condition and the node number\n\nmesh.conecCell{ 2, 1 } = [0 1 1  numElements + 1];\n\nthe following case only differs in the boundary condition and the node number\n\nmesh.conecCell{ 3, 1 } = [0 1 2  appNode];\n\nthe beam elements are formed by the first material, the second type of element, and no boundary conditions are applied to any element.\n\nfor i = 1:numElements\n  mesh.conecCell{ i + 3, 1 } = [1 2 0   i i + 1];\nend","category":"section"},{"location":"examples/beamLinearVibration/#initial-Conditions","page":"Linear beam vibration","title":"initial Conditions","text":"homogeneous initial conditions are considered, then an empty struct is set:\n\ninitialConds = struct();","category":"section"},{"location":"examples/beamLinearVibration/#analysisSettings","page":"Linear beam vibration","title":"analysisSettings","text":"analysisSettings               = struct();\nanalysisSettings.methodName    = 'newmark';\nanalysisSettings.deltaT        =   deltat;\nanalysisSettings.finalTime     =   tf;\nanalysisSettings.stopTolDeltau =   1e-8;\nanalysisSettings.stopTolForces =   1e-8;\nanalysisSettings.stopTolIts    =   10;","category":"section"},{"location":"examples/beamLinearVibration/#otherParams","page":"Linear beam vibration","title":"otherParams","text":"otherParams = struct();\notherParams.problemName = 'coRotationaluniformDynamicBeam';\n\nONSAS execution\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[coRotMatUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nThe second analysis case implements the linear elastic formulation\n\nmaterials.modelName  = 'elastic-linear';\notherParams.problemName = 'elastic-linearuniformDynamicBeam';\n\nONSAS execution\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[linElasMatUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);\n\nthe report is generated\n\noutputReport(modelProperties.outputDir, modelProperties.problemName);","category":"section"},{"location":"examples/beamLinearVibration/#Error-estimation","page":"Linear beam vibration","title":"Error estimation","text":"dofYendNode = 6 * (appNode) - 3;\ndofZendNode = 6 * (appNode) - 1;\n\nerror computed for each method in the application node of the external force\n\ndiflinearDispUy = linElasMatUs(dofYendNode, :)' - analyticDisY;\ndiflinearDispUz = linElasMatUs(dofZendNode, :)' - analyticDisZ;\ndifcoRotDispUy  = coRotMatUs(dofYendNode, :)'   - analyticDisY;\ndifcoRotDispUz  = coRotMatUs(dofZendNode, :)'   - analyticDisZ;\n\nerrlinearDispUy = norm(diflinearDispUy, 1) / norm(analyticDisY, 1);\nerrcoRotDispUy  = norm(difcoRotDispUy, 1) / norm(analyticDisY, 1);\nerrlinearDispUz = norm(diflinearDispUz, 1) / norm(analyticDisZ, 1);\nerrcoRotDispUz  = norm(difcoRotDispUz, 1) / norm(analyticDisZ, 1);\n\nthe numerical resolution is validated for both method and both directions.\n\nverifBoolean =  (errlinearDispUy <  5e-2) && (errcoRotDispUy  <  5e-2) && ...\n              (errlinearDispUz <  5e-2) && (errcoRotDispUz  <  5e-2);\n\nPlot parameters:\n\nlw = 2.0;\nlw2 = 1.0;\nms = 11;\nplotfontsize = 18;\n\nplot y-axis linear, co-rotational and analytic result\n\nfigure;\nhold on;\ngrid on;\nplot(ts, coRotMatUs(dofYendNode, :), 'r-x', 'linewidth', lw, 'markersize', ms);\nplot(ts, linElasMatUs(dofYendNode, :), 'k-o', 'linewidth', lw, 'markersize', ms);\nplot(ts, analyticDisY, 'b', 'linewidth', lw, 'markersize', ms);\nlegend('coRotational_{disp}', 'elastic-linear_{disp}', 'Analytic_{disp}', 'location', 'eastoutside');\nlabx = xlabel('time (s)');\nlaby = ylabel('displacement (m)');\nset(gca, 'linewidth', lw2, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/Uy', '-dpng');\n\nplot z-axis linear, co-rotational and analytic result\n\nfigure;\nhold on;\ngrid on;\nplot(ts, coRotMatUs(dofZendNode, :), 'r-x', 'linewidth', lw, 'markersize', ms);\nplot(ts, linElasMatUs(dofZendNode, :), 'k-o', 'linewidth', lw, 'markersize', ms);\nplot(ts, analyticDisZ, 'b', 'linewidth', lw, 'markersize', ms);\nlegend('coRotational_{disp}', 'elastic-linear_{disp}', 'Analytic_{disp}', 'location', 'eastoutside');\nlabx = xlabel('time (s)');\nlaby = ylabel('displacement (m)');\nset(gca, 'linewidth', lw2, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/Uy.png', '-dpng');\n\n<img src=\"../../assets/beamDynamicVibrationVerifUy.png\" alt=\"structure diagram\" width=\"500\"/>","category":"section"},{"location":"examples/ringPlaneStrain/#Plane-strain-ring-example","page":"Plane strain ring","title":"Plane strain ring example","text":"(Image: Octave script)\n\nIn this example a hollow cylinder submitted to an internal pressure p_i as shown in diagram depicted below is considered. The length of the cylinder is L_z  m and the internal and external radious are R_i and R_e, respectively.\n\n<img src=\"../../assets/linearCylinderPlaneStrain/ilusCylinderPlaneStrain.svg\" alt=\"linear cylinder diagram\" width=\"500\"/>\n\nBefore defining the structs, the workspace is cleaned, the ONSAS directory is added to the path and scalar geometry and material parameters are defined:\n\nclose all;\nif ~strcmp(getenv('TESTS_RUN'), 'yes')\n  clear all;\nend\naddpath(genpath([pwd '/../../src']));\nE = 210;\nnu = 0.3;\np = 0.01;\nL = .75;\nglobal Re\nglobal Ri\nRe = 200;\nRi = 100;","category":"section"},{"location":"examples/ringPlaneStrain/#Linear-analysis","page":"Plane strain ring","title":"Linear analysis","text":"","category":"section"},{"location":"examples/ringPlaneStrain/#Analytic-solution","page":"Plane strain ring","title":"Analytic solution","text":"The solution displacement field is extracted from chapter 4 of  (Timoshenko and Goodier, Theory of Elasticity, 3rd edition). The Navier's equation, imposing no temperature variation, no volumetric forces, and considering a radial dispalcement field leads to:\n\nnabla (nabla  textbfu(rthetaz) )  = 0\n\nDue to the symmetry of the problem mathbfmathitu_theta = 0  and also mathbf mathit textbfu (rthetaz)   = mathbf mathit textbfu(rz)    Thus according to the boundary conditions stated above mathitu_z(rz)=0 and the radial displacements field mathitu_r(r) only varies with r. Thereafter by imposing the boundary conditions stated above and substituting (E, nu) into Lamé parameters (lambda=frac Enu (1 + 2nu )(1 - 2nu ) and mu=frac Enu (1 + 2nu )) we obtain:\n\nu_r(r) = Ar + dfracBr  \nA = dfrac(1+nu)(1-2nu)R_i^2p_iE(R_e^2-R_i^2) quad\nB = dfrac(1+nu)R_i^2R_e^2p_iE(R_e^2-R_i^2)","category":"section"},{"location":"examples/ringPlaneStrain/#Numerical-solution","page":"Plane strain ring","title":"Numerical solution","text":"","category":"section"},{"location":"examples/ringPlaneStrain/#MEB-parameters","page":"Plane strain ring","title":"MEB parameters","text":"","category":"section"},{"location":"examples/ringPlaneStrain/#materials","page":"Plane strain ring","title":"materials","text":"The constitutive behavior of the material considered is isotropic linear elastic. Since only one material is considered, the structs defined for the materials contain only one entry:\n\nmaterials = struct();\nmaterials.modelName  = 'elastic-linear';\nmaterials.modelParams =  [E nu];","category":"section"},{"location":"examples/ringPlaneStrain/#elements","page":"Plane strain ring","title":"elements","text":"In this plane model, three kinds of elements are used: triangle for the solid, edges to add pressure loads and nodes to set additional boundary conditions for the numerical resolution. Since three kinds of elements are used, the struct has length 3:\n\nelements = struct();\nelements(1).elemType           = 'node';\nelements(2).elemType           = 'edge';\nelements(2).elemCrossSecParams = L;\nelements(3).elemType           = 'triangle';\nelements(3).elemTypeParams     = 2;\nelements(3).elemCrossSecParams = L;\n\nwhere elemCrossSecParams field sets the thickness of the edge and elemTypeParams sets the plane strain triangle element.","category":"section"},{"location":"examples/ringPlaneStrain/#boundaryConds","page":"Plane strain ring","title":"boundaryConds","text":"Three BCs are considered, one corresponding to a load and two for displacements. The first two BCs constrain displacements in x and y global directions respectively:\n\nboundaryConds = struct();\nboundaryConds(1).imposDispDofs = [1];\nboundaryConds(1).imposDispVals = [0];\nboundaryConds(2).imposDispDofs = [3];\nboundaryConds(2).imposDispVals = [0];\n\nthen the third BC corresponds to the normal pressure. This is introduced in local coordinates. The first entry is the force along the local x coordinate of the edge (tangent), the second is the moment along that direction and the third is the force towards the normal vector obtained by rotating the tangent vector 90 degrees in global axis z:\n\nboundaryConds(3).loadsCoordSys = 'local';\nboundaryConds(3).loadsTimeFact = @(t) t;\nboundaryConds(3).loadsBaseVals = [0 0 p 0 0 0];","category":"section"},{"location":"examples/ringPlaneStrain/#Mesh","page":"Plane strain ring","title":"Mesh","text":"The mesh can be read from the msh file. However, if any changes to the mesh are desired, the .geo file can be edited and the msh file can be re-generated using GMSH.\n\n<img src=\"../../assets/linearCylinderPlaneStrain/meshCylinderPlaneStrain.png\" alt=\"mesh plot\" width=\"500\"/>\n\nThe element properties are set using labels into GMSH follwing the MEB nomenclature. First triangle elements have linear elastic material so entry 1 of the materialṣ struct is assigned. Then for both node and edge elements any material is set. Next displacement boundary conditions are assigned to the element, since the problem is modeled into x-y plane, a constrain to avoid rotation along z is necessary. This is done fixing y and x displacements (using boundaryConds(1) and boundaryConds(2) as labels) on points 2 3 4 5. Finally the internal pressure is applied on the edge elements linked with curves from one to four (Circles 1-4 in Figure). In accordance with the orientation of the curve set in GMSH, the normal vector obtained in local coordinates is e_r so the internal pressure is assigned using boundaryConds(3). Once the mesh is created is read using:\n\nbase_msh = '';\nif strcmp(getenv('TESTS_RUN'), 'yes') && isfolder('examples')\n  base_msh = ['.' filesep 'examples' filesep 'ringPlaneStrain' filesep];\nend\nmesh = struct();\n[mesh.nodesCoords, mesh.conecCell] = meshFileReader([base_msh 'ring.msh']);","category":"section"},{"location":"examples/ringPlaneStrain/#initialConds","page":"Plane strain ring","title":"initialConds","text":"Any non-homogeneous initial conditions are considered, thereafter an empty struct is set:\n\ninitialConds = struct();","category":"section"},{"location":"examples/ringPlaneStrain/#Analysis-parameters","page":"Plane strain ring","title":"Analysis parameters","text":"The Newton-Raphson method is employed to solve 2 load steps. The ratio between finalTime and deltaT sets the number of load steps used to evaluate boundaryConds(3).loadsTimeFact function:\n\nanalysisSettings = struct();\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.stopTolIts    = 30;\nanalysisSettings.stopTolDeltau = 1.0e-12;\nanalysisSettings.stopTolForces = 1.0e-12;\nanalysisSettings.finalTime     = 1;\nanalysisSettings.deltaT        = .5;","category":"section"},{"location":"examples/ringPlaneStrain/#Output-parameters","page":"Plane strain ring","title":"Output parameters","text":"otherParams = struct();\notherParams.problemName = 'linear_PlaneStrain';\notherParams.plots_format = 'vtk';\n\nThe ONSAS software is executed for the parameters defined above and the displacement solution of each load(time) step is saved in matUsmatrix:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/ringPlaneStrain/#Verification","page":"Plane strain ring","title":"Verification","text":"The numerical and analytic solutions are compared at the final load step for the internal and external surface (since all the elements on the same surface have the same analytic solution):\n\nA = (p * (1 + nu) * (1 - 2 * nu) * Ri^2) / (E * (Re^2 - Ri^2));\nB = (p * (1 + nu) * Ri^2 * Re^2)   / (E * (Re^2 - Ri^2));\nanalyticValRi = A * Ri + B / Ri;\ndofXRi = 1;\nnumericalRi = matUs(dofXRi, end);\nanalyticValRe = A * Re + B / Re;\ndofXRe = (8 - 1) * 6 + 3;\nnumericalRe = matUs(dofXRe, end);\n\nThe numerical and analytical solution for the internal and external surface are plotted:\n\nlw = 2.0;\nms = 11;\nplotfontsize = 10;\nfigure;\nhold on;\ngrid on;\nplot(matUs(dofXRi, :), loadFactorsMat(:, 3), 'ro', 'linewidth', lw, 'markersize', ms);\nplot(linspace(0, analyticValRi, length(loadFactorsMat(:, 3))), loadFactorsMat(:, 3), 'k-', 'linewidth', lw, 'markersize', ms);\nplot(matUs(dofXRe, :), loadFactorsMat(:, 3), 'ro', 'linewidth', lw, 'markersize', ms);\nplot(linspace(0, analyticValRe, length(loadFactorsMat(:, 3))), loadFactorsMat(:, 3), 'k-', 'linewidth', lw, 'markersize', ms);\nlabx = xlabel('Displacement [m]');\nlaby = ylabel('\\lambda(t)');\nlegend('Numeric', 'Analytic', 'location', 'East');\nset(gca, 'linewidth', 1.2, 'fontsize', plotfontsize);\nset(labx, 'FontSize', plotfontsize);\nset(laby, 'FontSize', plotfontsize);\nprint('output/verifLinearRingPlaneStrain.png', '-dpng');\n\n<img src=\"../../assets/linearCylinderPlaneStrain/verifLinearCylinderPlaneStrain.png\" alt=\"verification plot\" width=\"500\"/>\n\nFinally the deformed configuration is illustrated:\n\n<img src=\"../../assets/linearCylinderPlaneStrain/defLinearCylinderPlaneStrain.png\" alt=\"def plot\" width=\"500\"/>","category":"section"},{"location":"examples/ringPlaneStrain/#Elastoplastic-analysis","page":"Plane strain ring","title":"Elastoplastic analysis","text":"","category":"section"},{"location":"examples/ringPlaneStrain/#Semi-analytic-solution","page":"Plane strain ring","title":"Semi-analytic solution","text":"The solution is extracted from Hill (The mathematical theroy of plasticity, 1950). The yielding pressure p_0 is defined as,\n\nY = dfrac2sigma_Y0sqrt3  \np_0 = dfracY2left(1+dfracR_i^2R_e^2right)\n\nThe radial displacement of the outer surface of the ring is given by,\n\nu_r(R_e) = textif p leq p_0 \ndfrac2 p R_eE left( dfracR_e^2R_i^2-1right) ( 1-nu^2 ) \ntextelse \ndfrac2pR_eEleft(dfracR_e^2R_i^2-1right)(1-nu^2)\n\nwhere c denotes the plastic front surface in the ring and is given by the implicit function,\n\ndfracpY = lnleft(dfraccR_iright) + dfrac12left(1-dfracc^ 2R_e^2right)","category":"section"},{"location":"examples/ringPlaneStrain/#Numerical-solution-2","page":"Plane strain ring","title":"Numerical solution","text":"E = 210;\nnu = 0.3;\nH = 0;\nsigmaY0 = 0.24;\nL = .75;\np = 0.01;","category":"section"},{"location":"examples/ringPlaneStrain/#MEB-parameters-2","page":"Plane strain ring","title":"MEB parameters","text":"","category":"section"},{"location":"examples/ringPlaneStrain/#materials-2","page":"Plane strain ring","title":"materials","text":"The constitutive behavior of the material considered is isotropic hardening. Since only one material is considered, the structs defined for the materials contain only one entry:\n\nmaterials.modelName  = 'isotropicHardening';\nmaterials.modelParams =  [E nu H sigmaY0];","category":"section"},{"location":"examples/ringPlaneStrain/#elements-2","page":"Plane strain ring","title":"elements","text":"The elements struct is the same as the previous model.","category":"section"},{"location":"examples/ringPlaneStrain/#boundaryConds-2","page":"Plane strain ring","title":"boundaryConds","text":"The BC struct is the same as in the elastic-linear case. However the loadsTimeFact function can be modified to consider unloading as follows.\n\nboundaryConds(3).loadsTimeFact = @(t) t * (t <= 19) + (t - (t - 19) * 2) * (t > 19);","category":"section"},{"location":"examples/ringPlaneStrain/#initialConds-2","page":"Plane strain ring","title":"initialConds","text":"Any non-homogeneous initial conditions are considered, thereafter the struc is the same as in the previous example.","category":"section"},{"location":"examples/ringPlaneStrain/#Mesh-2","page":"Plane strain ring","title":"Mesh","text":"The mesh can be read from the msh file. The same mesh as in the elastic-linear case is considered for this problem.\n\nConec = myCell2Mat(mesh.conecCell);\nelems = size(Conec, 1);","category":"section"},{"location":"examples/ringPlaneStrain/#Analysis-parameters-2","page":"Plane strain ring","title":"Analysis parameters","text":"The Newton-Raphson method is employed to solve 19 load steps. The ratio between finalTime and deltaT sets the number of load steps used to evaluate boundaryConds(3).loadsTimeFact function:\n\nanalysisSettings.methodName    = 'newtonRaphson';\nanalysisSettings.stopTolIts    = 30;\nanalysisSettings.stopTolDeltau = 1.0e-8;\nanalysisSettings.stopTolForces = 1.0e-6;\nanalysisSettings.finalTime     = 19;\nanalysisSettings.deltaT        = 1;","category":"section"},{"location":"examples/ringPlaneStrain/#Output-parameters-2","page":"Plane strain ring","title":"Output parameters","text":"otherParams.problemName = 'EPP_PlaneStrain';\notherParams.plots_format = 'vtk';\n\nThe ONSAS software is executed for the parameters defined above and the displacement solution of each load(time) step is saved in matUsmatrix:\n\n[modelCurrSol, modelProperties, BCsData] = initONSAS(materials, elements, boundaryConds, initialConds, mesh, analysisSettings, otherParams);\n\nAfter that the structs are used to perform the numerical time analysis\n\n[matUs, loadFactorsMat, modelSolutions] = solveONSAS(modelCurrSol, modelProperties, BCsData);","category":"section"},{"location":"examples/ringPlaneStrain/#Verification-2","page":"Plane strain ring","title":"Verification","text":"The numerical and analytic solutions are compared for the external surface (since all the elements on the same surface have the same analytic solution):\n\nglobal Y\nY = 2 * sigmaY0 / sqrt(3);\np0 = Y / 2 * (1 - Ri^2 / Re^2); % Yielding pressure\npressure_vals = loadFactorsMat(:, 3) * p;\ncvals = zeros(length(pressure_vals), 1);\nubAna = zeros(length(pressure_vals), 1);\nfor i = 1:length(cvals)\n  p = pressure_vals(i);\n  if i == 1\n    % val = fsolve(@(c)cValue(c,p,Y,a,b), a) ;\n    val = fsolve(@(c)cValue(c, p, Y, Ri, Re), Ri);\n  else\n    % val = fsolve(@(c)cValue(c,p,Y,a,b), cvals(i-1)) ;\n    val = fsolve(@(c)cValue(c, p, Y, Ri, Re), cvals(i - 1));\n  end\n  cvals(i) = val;\nend\nfor i = 1:length(cvals)\n  p = pressure_vals(i);\n  if p < p0\n    % ubAna(i) = 2*p*b / ( E*( b^2/a^2-1 ) ) * (1-nu^2) ;\n    ubAna(i) = 2 * p * Re / (E * (Re^2 / Ri^2 - 1)) * (1 - nu^2);\n  else\n    c = cvals(i);\n    % ubAna(i) = Y*c^2/(E*b) * (1-nu^2) ;\n    ubAna(i) = Y * c^2 / (E * Re) * (1 - nu^2);\n  end\nend","category":"section"},{"location":"examples/ringPlaneStrain/#Plots","page":"Plane strain ring","title":"Plots","text":"lw = 2.0;\nms = 11;\nplotFontSize = 10;\nfig = figure;\nhold on;\ngrid on;\nnode = 5;\ndofX = node * 6 - 5;\nubNum = matUs(dofX, :);\nplot(ubNum, pressure_vals, 'b-o', 'linewidth', lw, 'markersize', ms);\nplot(ubAna, pressure_vals, 'g-x', 'linewidth', lw, 'markersize', ms);\nlegend ({'FEM', 'Analytic'}, 'location', 'east');\nlabx = xlabel('u_b');\nlaby = ylabel('p');\ntit = title('p-u_b');\nset(labx, 'fontsize', plotFontSize * .8);\nset(laby, 'fontsize', plotFontSize * .8);\nset(tit, 'fontsize', plotFontSize);\n\nThe numerical solution is verified for both cases:\n\nanalyticCheckTolerance = 1e-2;\nverifBoolean = ((numericalRi - analyticValRi) < analyticCheckTolerance) && ...\n               ((numericalRe - analyticValRe) < analyticCheckTolerance) && ...\n               ((ubNum(end) - ubAna(end)) < analyticCheckTolerance);","category":"section"}]
}
